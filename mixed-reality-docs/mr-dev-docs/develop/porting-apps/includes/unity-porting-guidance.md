---
ms.openlocfilehash: bcc899a178917a8ef184b4c11bd724df71f7b5c0
ms.sourcegitcommit: 4bb5544a0c74ac4e9766bab3401c9b30ee170a71
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/27/2020
ms.locfileid: "92638535"
---
# <a name="project-settings"></a>[<span data-ttu-id="c73b9-101">项目设置</span><span class="sxs-lookup"><span data-stu-id="c73b9-101">Project settings</span></span>](#tab/project)

### <a name="1-review-the-common-porting-steps-listed-above"></a><span data-ttu-id="c73b9-102">1. 查看上面列出的常见移植步骤</span><span class="sxs-lookup"><span data-stu-id="c73b9-102">1. Review the common porting steps listed above</span></span>

<span data-ttu-id="c73b9-103">查看上面列出的常见步骤，确保正确设置开发环境。</span><span class="sxs-lookup"><span data-stu-id="c73b9-103">Review the common steps listed above to make sure your development environment is set up correctly.</span></span> <span data-ttu-id="c73b9-104">在步骤 #3 中，如果使用的是 Visual Studio，则应选择 " **使用 Unity 的游戏开发** " 工作负荷。</span><span class="sxs-lookup"><span data-stu-id="c73b9-104">In step #3, if you're using Visual Studio you should select the **Game Development with Unity** workload.</span></span> <span data-ttu-id="c73b9-105">由于将在下一步中安装较新版本的 Unity，因此可以取消选中 "Unity 编辑器可选" 组件。</span><span class="sxs-lookup"><span data-stu-id="c73b9-105">You may deselect the "Unity Editor optional" component since you'll be installing a newer version of Unity in the next step.</span></span>

### <a name="2-upgrade-to-the-latest-public-build-of-unity-with-windows-mr-support"></a><span data-ttu-id="c73b9-106">2. 升级到具有 Windows MR 支持的 Unity 的最新公共版本</span><span class="sxs-lookup"><span data-stu-id="c73b9-106">2. Upgrade to the latest public build of Unity with Windows MR Support</span></span>
1. <span data-ttu-id="c73b9-107">下载最新建议的具有混合现实支持 [的 Unity 公共内部版本](../../install-the-tools.md) 。</span><span class="sxs-lookup"><span data-stu-id="c73b9-107">Download the latest [recommended public build of Unity](../../install-the-tools.md) with mixed reality support.</span></span>
2. <span data-ttu-id="c73b9-108">在开始之前保存项目的副本</span><span class="sxs-lookup"><span data-stu-id="c73b9-108">Save a copy of your project before you get started</span></span>
3. <span data-ttu-id="c73b9-109">如果你的项目是基于早期版本的 Unity 生成的，请查看 Unity 上提供的 [文档](https://docs.unity3d.com/Manual/UpgradeGuides.html) 。</span><span class="sxs-lookup"><span data-stu-id="c73b9-109">Review the [documentation](https://docs.unity3d.com/Manual/UpgradeGuides.html) available from Unity on upgrading if your project was built on an older version of Unity.</span></span>
4. <span data-ttu-id="c73b9-110">按照 Unity 站点上的 [说明](https://docs.unity3d.com/Manual/APIUpdater.html) 使用其自动 API 更新程序</span><span class="sxs-lookup"><span data-stu-id="c73b9-110">Follow the [instructions](https://docs.unity3d.com/Manual/APIUpdater.html) on Unity's site for using their automatic API updater</span></span>
5. <span data-ttu-id="c73b9-111">检查并查看你是否需要进行其他更改以使你的项目运行，并处理剩余的错误和警告。</span><span class="sxs-lookup"><span data-stu-id="c73b9-111">Check and see if there are additional changes that you need to make to get your project running, and work through any remaining errors and warnings.</span></span> 

> [!Note] 
> <span data-ttu-id="c73b9-112">如果你有依赖的中间件，请检查你是否正在使用最新版本， () 下面的步骤3中的更多详细信息。</span><span class="sxs-lookup"><span data-stu-id="c73b9-112">If you have middleware that you depend on, check that you're using the latest release (more details in step 3 below).</span></span>

### <a name="3-upgrade-your-middleware-to-the-latest-versions"></a><span data-ttu-id="c73b9-113">3. 将中间件升级到最新版本</span><span class="sxs-lookup"><span data-stu-id="c73b9-113">3. Upgrade your middleware to the latest versions</span></span>

<span data-ttu-id="c73b9-114">对于任何 Unity 更新，都有可能需要更新游戏或应用程序所依赖的一个或多个中间件包。</span><span class="sxs-lookup"><span data-stu-id="c73b9-114">With any Unity update, there's a good chance that you'll need to update one or more middleware packages that your game or application depends on.</span></span> <span data-ttu-id="c73b9-115">此外，最新的中间件是最新的，最新的中间件会在整个移植过程中增加成功的可能性。</span><span class="sxs-lookup"><span data-stu-id="c73b9-115">Additionally, being up to date with the latest middleware increases the likelihood of success throughout the rest of the porting process.</span></span>

### <a name="4-target-your-application-to-run-on-win32"></a><span data-ttu-id="c73b9-116">4. 将应用程序定位到在 Win32 上运行</span><span class="sxs-lookup"><span data-stu-id="c73b9-116">4. Target your application to run on Win32</span></span>

<span data-ttu-id="c73b9-117">从 Unity 应用程序内部：</span><span class="sxs-lookup"><span data-stu-id="c73b9-117">From inside your Unity application:</span></span>

* <span data-ttu-id="c73b9-118">导航到 "文件-> 生成设置"</span><span class="sxs-lookup"><span data-stu-id="c73b9-118">Navigate to File -> Build Settings</span></span>
* <span data-ttu-id="c73b9-119">选择 "PC、Mac、Linux 独立版"</span><span class="sxs-lookup"><span data-stu-id="c73b9-119">Select "PC, Mac, Linux Standalone"</span></span>
* <span data-ttu-id="c73b9-120">将目标平台设置为 "Windows"</span><span class="sxs-lookup"><span data-stu-id="c73b9-120">Set target platform to "Windows"</span></span>
* <span data-ttu-id="c73b9-121">将体系结构设置为 "x86" 选择 "切换平台"</span><span class="sxs-lookup"><span data-stu-id="c73b9-121">Set architecture to "x86" Select "Switch Platform"</span></span>

> [!NOTE] 
> <span data-ttu-id="c73b9-122">如果你的应用程序在特定于设备的服务上有任何依赖关系，例如，从流中进行匹配，则需要在此步骤中禁用它们。</span><span class="sxs-lookup"><span data-stu-id="c73b9-122">If your application has any dependencies on device-specific services, such as match making from Steam, you'll need to disable them at this step.</span></span> <span data-ttu-id="c73b9-123">你可以挂钩到 Windows 稍后提供的等效服务。</span><span class="sxs-lookup"><span data-stu-id="c73b9-123">You can hook up to the equivalent services that Windows provides later on.</span></span>

### <a name="5-setup-your-windows-mixed-reality-hardware"></a><span data-ttu-id="c73b9-124">5. 设置 Windows Mixed Reality 硬件</span><span class="sxs-lookup"><span data-stu-id="c73b9-124">5. Setup your Windows Mixed Reality hardware</span></span>
1. <span data-ttu-id="c73b9-125">查看[沉浸式耳机安装程序](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/before-you-start
)中的步骤</span><span class="sxs-lookup"><span data-stu-id="c73b9-125">Review steps in [Immersive headset setup](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/before-you-start
)</span></span>
2. <span data-ttu-id="c73b9-126">了解如何 [使用 Windows Mixed reality 模拟器](../../platform-capabilities-and-apis/using-the-windows-mixed-reality-simulator.md) 并 [导航 windows mixed reality 主页](../../../discover/navigating-the-windows-mixed-reality-home.md)</span><span class="sxs-lookup"><span data-stu-id="c73b9-126">Learn about [Using the Windows Mixed Reality simulator](../../platform-capabilities-and-apis/using-the-windows-mixed-reality-simulator.md) and [Navigating the Windows Mixed Reality home](../../../discover/navigating-the-windows-mixed-reality-home.md)</span></span>

### <a name="6-target-your-application-to-run-on-windows-mixed-reality"></a><span data-ttu-id="c73b9-127">6. 将应用程序设定为在 Windows Mixed Reality 上运行</span><span class="sxs-lookup"><span data-stu-id="c73b9-127">6. Target your application to run on Windows Mixed Reality</span></span>
1. <span data-ttu-id="c73b9-128">首先，必须将特定于特定的 VR SDK 的任何其他库支持删除或有条件地编译掉。</span><span class="sxs-lookup"><span data-stu-id="c73b9-128">First, you must remove or conditionally compile out any other library support specific to a particular VR SDK.</span></span> <span data-ttu-id="c73b9-129">这些资产经常以与其他 VR Sdk （如 Windows Mixed Reality）不兼容的方式更改项目的设置和属性。</span><span class="sxs-lookup"><span data-stu-id="c73b9-129">Those assets frequently change settings and properties on your project in ways that are incompatible with other VR SDKs, such as Windows Mixed Reality.</span></span>
    * <span data-ttu-id="c73b9-130">例如，如果你的项目引用 SteamVR SDK，则需要将你的项目更新为，以改用支持 Windows Mixed Reality 和 SteamVR 的 Unity 公共 VR Api。</span><span class="sxs-lookup"><span data-stu-id="c73b9-130">For example, if your project references the SteamVR SDK, you'll need to update your project to instead use Unity's common VR APIs that support both Windows Mixed Reality and SteamVR.</span></span>
    * <span data-ttu-id="c73b9-131">即将推出其他用于有条件地排除其他 VR Sdk 的特定步骤。</span><span class="sxs-lookup"><span data-stu-id="c73b9-131">Specific steps for conditionally excluding other VR SDKs are coming soon.</span></span>
2. <span data-ttu-id="c73b9-132">在 Unity 项目中， [面向 Windows 10 SDK](../../unity/tutorials/holograms-100.md#target-windows-10-sdk)</span><span class="sxs-lookup"><span data-stu-id="c73b9-132">In your Unity project, [target the Windows 10 SDK](../../unity/tutorials/holograms-100.md#target-windows-10-sdk)</span></span>
3. <span data-ttu-id="c73b9-133">对于每个场景， [设置照相机](../../unity/tutorials/holograms-100.md#chapter-2---setup-the-camera)</span><span class="sxs-lookup"><span data-stu-id="c73b9-133">For each scene, [setup the camera](../../unity/tutorials/holograms-100.md#chapter-2---setup-the-camera)</span></span>

### <a name="7-use-the-stage-to-place-content-on-the-floor"></a><span data-ttu-id="c73b9-134">7. 使用舞台将内容放到地面上</span><span class="sxs-lookup"><span data-stu-id="c73b9-134">7. Use the stage to place content on the floor</span></span>

<span data-ttu-id="c73b9-135">您可以在各种 [经验](../../../design/coordinate-systems.md)范围内构建混合现实体验。</span><span class="sxs-lookup"><span data-stu-id="c73b9-135">You can build Mixed Reality experiences across a wide range of [experience scales](../../../design/coordinate-systems.md).</span></span>

<span data-ttu-id="c73b9-136">如果要移植 **固定规模的体验** ，必须确保将 Unity 设置为 **静止** 跟踪空间类型：</span><span class="sxs-lookup"><span data-stu-id="c73b9-136">If you're porting a **seated-scale experience** , you must ensure Unity is set to the **Stationary** tracking space type:</span></span>

```cs
XRDevice.SetTrackingSpaceType(TrackingSpaceType.Stationary);
```

<span data-ttu-id="c73b9-137">上述代码将设置 Unity 的世界坐标系统，以跟踪 [固定的引用框架](../../../design/coordinate-systems.md#spatial-coordinate-systems)。</span><span class="sxs-lookup"><span data-stu-id="c73b9-137">This above code sets Unity's world coordinate system to track the [stationary frame of reference](../../../design/coordinate-systems.md#spatial-coordinate-systems).</span></span> <span data-ttu-id="c73b9-138">在静止跟踪模式下，在应用程序启动时，位于该编辑器中的内容仅在照相机默认位置的前面 ("向前" 为-Z) 出现在用户的前面。</span><span class="sxs-lookup"><span data-stu-id="c73b9-138">In the Stationary tracking mode, content placed in the editor just in front of the camera's default location (forward is -Z) appears in front of the user when the app launches.</span></span> <span data-ttu-id="c73b9-139">若要 recenter 用户的固定来源，可以调用 Unity 的 [XR。InputTracking. Recenter](https://docs.unity3d.com/ScriptReference/XR.InputTracking.Recenter.html) 方法。</span><span class="sxs-lookup"><span data-stu-id="c73b9-139">To recenter the user's seated origin, you can call Unity's [XR.InputTracking.Recenter](https://docs.unity3d.com/ScriptReference/XR.InputTracking.Recenter.html) method.</span></span>

<span data-ttu-id="c73b9-140">如果迁移的是 **大规模体验** 或 **房间规模体验** ，将会相对于地面放置内容。</span><span class="sxs-lookup"><span data-stu-id="c73b9-140">If you're porting a **standing-scale experience** or **room-scale experience** , you'll be placing content relative to the floor.</span></span> <span data-ttu-id="c73b9-141">使用 **[空间阶段](../../../design/coordinate-systems.md#spatial-coordinate-systems)** （表示用户在首次运行期间设置的已定义的层级来源和可选房间边界）的原因。</span><span class="sxs-lookup"><span data-stu-id="c73b9-141">You reason about the user's floor using the **[spatial stage](../../../design/coordinate-systems.md#spatial-coordinate-systems)** , which represents the user's defined floor-level origin and optional room boundary, set up during first run.</span></span> <span data-ttu-id="c73b9-142">对于这些体验，必须确保将 Unity 设置为 **RoomScale** 跟踪空间类型。</span><span class="sxs-lookup"><span data-stu-id="c73b9-142">For these experiences, you must ensure Unity is set to the **RoomScale** tracking space type.</span></span> <span data-ttu-id="c73b9-143">尽管 RoomScale 是默认值，但你需要对其进行显式设置，并确保返回 true，以便捕获用户将其计算机从其校准的房间离开的情况：</span><span class="sxs-lookup"><span data-stu-id="c73b9-143">While RoomScale is the default, you'll want to set it explicitly and ensure you get back true, to catch situations where the user has moved their computer away from the room they calibrated:</span></span>

```cs
if (XRDevice.SetTrackingSpaceType(TrackingSpaceType.RoomScale))
{
    // RoomScale mode was set successfully.  App can now assume that y=0 in Unity world coordinate represents the floor.
}
else
{
    // RoomScale mode was not set successfully.  App cannot make assumptions about where the floor plane is.
}
```

<span data-ttu-id="c73b9-144">应用成功设置 RoomScale 跟踪空间类型后，放置在 y = 0 平面上的内容将显示在地面上。</span><span class="sxs-lookup"><span data-stu-id="c73b9-144">Once your app successfully sets the RoomScale tracking space type, content placed on the y=0 plane will appear on the floor.</span></span> <span data-ttu-id="c73b9-145">位于 (0，0，0) 的原点将是用户在房间设置期间考验的特定位置，并以-Z 表示在安装过程中所面临的正向方向。</span><span class="sxs-lookup"><span data-stu-id="c73b9-145">The origin at (0, 0, 0) will be the specific place on the floor where the user stood during room setup, with -Z representing the forward direction they were facing during setup.</span></span>

<span data-ttu-id="c73b9-146">在脚本代码中，您可以对 UnityEngine 调用 TryGetGeometry 方法来获取边界多边形，并指定 "TrackedArea" 的边界类型。</span><span class="sxs-lookup"><span data-stu-id="c73b9-146">In script code, you can then call the TryGetGeometry method on you're the UnityEngine.Experimental.XR.Boundary type to get a boundary polygon, specifying a boundary type of TrackedArea.</span></span> <span data-ttu-id="c73b9-147">如果用户定义了边界 (你获取了) 的顶点列表，则可以安全地向用户提供一个 **会议室规模的体验** ，用户可在其中浏览你创建的场景。</span><span class="sxs-lookup"><span data-stu-id="c73b9-147">If the user defined a boundary (you get back a list of vertices), it's safe to deliver a **room-scale experience** to the user, where they can walk around the scene you create.</span></span>

<span data-ttu-id="c73b9-148">当用户接近边界时，系统将自动渲染边界。</span><span class="sxs-lookup"><span data-stu-id="c73b9-148">The system will automatically render the boundary when the user approaches it.</span></span> <span data-ttu-id="c73b9-149">您的应用程序不需要使用此多边形来呈现边界本身。</span><span class="sxs-lookup"><span data-stu-id="c73b9-149">Your app does not need to use this polygon to render the boundary itself.</span></span>

<span data-ttu-id="c73b9-150">有关详细信息，请参阅 [Unity 页中的坐标系统](../../unity/coordinate-systems-in-unity.md) 。</span><span class="sxs-lookup"><span data-stu-id="c73b9-150">For more information, see the [Coordinate systems in Unity](../../unity/coordinate-systems-in-unity.md) page.</span></span>

<!-- Some applications use a rectangle to constrain their interaction. Retrieving the largest inscribed rectangle is not directly supported in the UWP API or Unity. The example code linked to below shows how to find a rectangle within the traced bounds. It's heuristic-based so may not find the optimal solution, however, results are consistent with expectations. Parameters in the algorithm can be tuned to find more precise results at the cost of processing time. The algorithm is in a fork of the Mixed Reality Toolkit that uses the 5.6 preview MRTP version of Unity. This isn't publicly available. The code should be directly usable in 2017.2 and higher versions of Unity. The code will be ported to the current MRTK in the near future. -->

<span data-ttu-id="c73b9-151">结果示例：</span><span class="sxs-lookup"><span data-stu-id="c73b9-151">Example of results:</span></span>

![结果示例](../../porting-apps/images/largestrectangle-400px.jpg)

<span data-ttu-id="c73b9-153">算法基于 Daniel Smilkov：[多边形中的最大矩形](https://d3plus.org/blog/behind-the-scenes/2014/07/08/largest-rect/)的博客</span><span class="sxs-lookup"><span data-stu-id="c73b9-153">Algorithm is based on a blog by Daniel Smilkov: [Largest rectangle in a polygon](https://d3plus.org/blog/behind-the-scenes/2014/07/08/largest-rect/)</span></span>

### <a name="8-work-through-your-input-model"></a><span data-ttu-id="c73b9-154">8. 通过输入模型工作</span><span class="sxs-lookup"><span data-stu-id="c73b9-154">8. Work through your input model</span></span>

<span data-ttu-id="c73b9-155">每个面向现有 HMD 的游戏或应用程序都将具有一组可处理的输入，其所需的输入类型和体验所需的特定 Api 以及用于获取这些输入的特定 Api。</span><span class="sxs-lookup"><span data-stu-id="c73b9-155">Each game or application targeting an existing HMD will have a set of inputs that it handles, types of inputs that it needs for the experience, and specific APIs that it calls to get those inputs.</span></span> <span data-ttu-id="c73b9-156">我们已经投入了大量努力，尽可能简单直接地利用 Windows Mixed Reality 中提供的输入。</span><span class="sxs-lookup"><span data-stu-id="c73b9-156">We've invested in trying to make it as simple and straightforward as possible to take advantage of the inputs available in Windows Mixed Reality.</span></span>
1. <span data-ttu-id="c73b9-157">有关 Windows Mixed Reality 如何公开输入的详细信息以及如何映射到你的应用程序可以执行的操作的详细信息，请参阅相邻选项卡中的 **Unity 的输入移植指南** 。</span><span class="sxs-lookup"><span data-stu-id="c73b9-157">Read through the **Input porting guide for Unity** in the adjacent tab for details of how Windows Mixed Reality exposes input, and how that maps to what your application may do today.</span></span>
2. <span data-ttu-id="c73b9-158">选择是要使用 Unity 的跨 VR-SDK 输入 API 还是 MR 专用输入 API。</span><span class="sxs-lookup"><span data-stu-id="c73b9-158">Choose whether you're going to leverage Unity's cross-VR-SDK input API, or the MR-specific input API.</span></span> <span data-ttu-id="c73b9-159">当前，Unity VR 应用使用一般输入. GetButton/GetAxis Api 进行 [Oculus 输入](https://docs.unity3d.com/Manual/OculusControllers.html) 和 [OpenVR 输入](https://docs.unity3d.com/Manual/OpenVRControllers.html)。</span><span class="sxs-lookup"><span data-stu-id="c73b9-159">The general Input.GetButton/Input.GetAxis APIs are used by Unity VR apps today for [Oculus input](https://docs.unity3d.com/Manual/OculusControllers.html) and [OpenVR input](https://docs.unity3d.com/Manual/OpenVRControllers.html).</span></span> <span data-ttu-id="c73b9-160">如果你的应用程序已使用这些用于运动控制器的 Api，这是最简单的路径，你只需在输入管理器中重新映射按钮和轴即可。</span><span class="sxs-lookup"><span data-stu-id="c73b9-160">If your apps are already using these APIs for motion controllers, this is the easiest path - you should just need to remap buttons and axes in the Input Manager.</span></span>
    * <span data-ttu-id="c73b9-161">您可以使用一般的 GetButton/GetAxis Api 或 MR 专用 UnityEngine. XR Api 来访问 Unity 中的运动控制器数据。. Api。</span><span class="sxs-lookup"><span data-stu-id="c73b9-161">You can access motion controller data in Unity using either the general cross-VR-SDK Input.GetButton/Input.GetAxis APIs or the MR-specific UnityEngine.XR.WSA.Input APIs.</span></span> <span data-ttu-id="c73b9-162"> (在 Unity 5.6) 中的 UnityEngine 命名空间中。</span><span class="sxs-lookup"><span data-stu-id="c73b9-162">(previously in the UnityEngine.XR.WSA.Input namespace in Unity 5.6)</span></span>
    * <span data-ttu-id="c73b9-163">请参阅组合游戏板和运动控制器的 [工具包中的示例](https://github.com/Microsoft/HoloToolkit-Unity/pull/572) 。</span><span class="sxs-lookup"><span data-stu-id="c73b9-163">See the [example in Toolkit](https://github.com/Microsoft/HoloToolkit-Unity/pull/572) that combines gamepad and motion controllers.</span></span>

### <a name="9-performance-testing-and-tuning"></a><span data-ttu-id="c73b9-164">9. 性能测试和优化</span><span class="sxs-lookup"><span data-stu-id="c73b9-164">9. Performance testing and tuning</span></span>

<span data-ttu-id="c73b9-165">Windows Mixed Reality 将在各种设备上可用，范围从高端游戏电脑到广泛市场主流 Pc。</span><span class="sxs-lookup"><span data-stu-id="c73b9-165">Windows Mixed Reality will be available on a broad class of devices, ranging from high end gaming PCs, down to broad market mainstream PCs.</span></span> <span data-ttu-id="c73b9-166">根据你的目标市场，你的应用程序的可用计算和图形预算有很大的差异。</span><span class="sxs-lookup"><span data-stu-id="c73b9-166">Depending on what market you're targeting, there's a significant difference in the available compute and graphics budgets for your application.</span></span> <span data-ttu-id="c73b9-167">在此迁移过程中，你可能会利用高级 PC，并为应用提供大量的计算和图形预算。</span><span class="sxs-lookup"><span data-stu-id="c73b9-167">During this porting exercise, you're likely leveraging a premium PC, and have had significant compute and graphics budgets available to your app.</span></span> <span data-ttu-id="c73b9-168">如果你希望将应用程序提供给更广泛的受众，则应在 [你想要面向的代表硬件](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines)上测试和分析你的应用程序。</span><span class="sxs-lookup"><span data-stu-id="c73b9-168">If you wish to make your app available to a broader audience, you should test and profile your app on [the representative hardware that you wish to target](https://docs.microsoft.com/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines).</span></span>

<span data-ttu-id="c73b9-169">[Unity](https://docs.unity3d.com/Manual/Profiler.html)和[Visual Studio](https://docs.microsoft.com/visualstudio/profiling/index)都包含性能探查器， [Microsoft](../../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md)和[Intel](https://software.intel.com/articles/vr-content-developer-guide)发布有关性能分析和优化的指导原则。</span><span class="sxs-lookup"><span data-stu-id="c73b9-169">Both [Unity](https://docs.unity3d.com/Manual/Profiler.html) and [Visual Studio](https://docs.microsoft.com/visualstudio/profiling/index) include performance profilers, and both [Microsoft](../../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md) and [Intel](https://software.intel.com/articles/vr-content-developer-guide) publish guidelines on performance profiling and optimization.</span></span> <span data-ttu-id="c73b9-170">在 [了解混合现实的性能](../../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md)方面，提供了有关性能的广泛讨论。</span><span class="sxs-lookup"><span data-stu-id="c73b9-170">There's an extensive discussion of performance available at [Understanding Performance for Mixed Reality](../../platform-capabilities-and-apis/understanding-performance-for-mixed-reality.md).</span></span> <span data-ttu-id="c73b9-171">此外，针对 [unity 的性能建议](../../unity/performance-recommendations-for-unity.md)下的 unity 有特定的详细信息。</span><span class="sxs-lookup"><span data-stu-id="c73b9-171">Further, there are specific details for Unity under [Performance Recommendations for Unity](../../unity/performance-recommendations-for-unity.md).</span></span>

# <a name="input-mapping"></a>[<span data-ttu-id="c73b9-172">输入映射</span><span class="sxs-lookup"><span data-stu-id="c73b9-172">Input mapping</span></span>](#tab/input)

<span data-ttu-id="c73b9-173">你可以使用以下两种方法之一将输入逻辑移植到 Windows Mixed Reality： Unity 的一般输入. GetButton/GetAxis Api，跨越多个平台或特定于 Windows 的 XR。WSA.输入 Api，专门为运动控制器和 HoloLens 提供更丰富的数据。</span><span class="sxs-lookup"><span data-stu-id="c73b9-173">You can port your input logic to Windows Mixed Reality using one of two approaches, Unity's general Input.GetButton/GetAxis APIs that span across multiple platforms, or the Windows-specific XR.WSA.Input APIs that offer richer data specifically for motion controllers and HoloLens hands.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="c73b9-174">如果你使用的是 HP 回音 G2 控制器，请参阅 [此文](../../unity/unity-reverb-g2-controllers.md) ，了解更多输入映射说明。</span><span class="sxs-lookup"><span data-stu-id="c73b9-174">If you're using HP Reverb G2 controllers, please refer to [this article](../../unity/unity-reverb-g2-controllers.md) for additional input mapping instructions.</span></span>

## <a name="general-inputgetbuttongetaxis-apis"></a><span data-ttu-id="c73b9-175">General GetButton/GetAxis Api</span><span class="sxs-lookup"><span data-stu-id="c73b9-175">General Input.GetButton/GetAxis APIs</span></span>

<span data-ttu-id="c73b9-176">Unity 目前使用其常规输入. GetButton/GetAxis Api 来公开 [OCULUS SDK](https://docs.unity3d.com/Manual/OculusControllers.html) 和 [OpenVR SDK](https://docs.unity3d.com/Manual/OpenVRControllers.html)的输入。</span><span class="sxs-lookup"><span data-stu-id="c73b9-176">Unity currently uses its general Input.GetButton/Input.GetAxis APIs to expose input for [the Oculus SDK](https://docs.unity3d.com/Manual/OculusControllers.html) and [the OpenVR SDK](https://docs.unity3d.com/Manual/OpenVRControllers.html).</span></span> <span data-ttu-id="c73b9-177">如果你的应用程序已在使用这些 Api 进行输入，则这是在 Windows Mixed Reality 中支持运动控制器的最简单途径：只需重新映射输入管理器中的按钮和轴即可。</span><span class="sxs-lookup"><span data-stu-id="c73b9-177">If your apps are already using these APIs for input, this is the easiest path for supporting motion controllers in Windows Mixed Reality: you should just need to remap buttons and axes in the Input Manager.</span></span>

<span data-ttu-id="c73b9-178">有关详细信息，请参阅 [Unity 按钮/轴映射表](../../unity/gestures-and-motion-controllers-in-unity.md#unity-buttonaxis-mapping-table) 和 [常见 Unity api 的概述](../../unity/gestures-and-motion-controllers-in-unity.md#common-unity-apis-inputgetbuttongetaxis)。</span><span class="sxs-lookup"><span data-stu-id="c73b9-178">For more information, see the [Unity button/axis mapping table](../../unity/gestures-and-motion-controllers-in-unity.md#unity-buttonaxis-mapping-table) and the [overview of the common Unity APIs](../../unity/gestures-and-motion-controllers-in-unity.md#common-unity-apis-inputgetbuttongetaxis).</span></span>

## <a name="windows-specific-xrwsainput-apis"></a><span data-ttu-id="c73b9-179">Windows 特定的 XR。WSA.输入 Api</span><span class="sxs-lookup"><span data-stu-id="c73b9-179">Windows-specific XR.WSA.Input APIs</span></span>

<span data-ttu-id="c73b9-180">如果应用已为每个平台构建自定义输入逻辑，则可以选择在 **UnityEngine** 命名空间下使用特定于 Windows 的空间输入 api。</span><span class="sxs-lookup"><span data-stu-id="c73b9-180">If your app already builds custom input logic for each platform, you can choose to use the Windows-specific spatial input APIs under the **UnityEngine.XR.WSA.Input** namespace.</span></span> <span data-ttu-id="c73b9-181">这样，你就可以访问其他信息（如位置准确性或源类型），从而让你能够在 HoloLens 上区分双手和控制器。</span><span class="sxs-lookup"><span data-stu-id="c73b9-181">This lets you access additional information, such as position accuracy or the source kind, letting you tell hands and controllers apart on HoloLens.</span></span>

> [!NOTE]
> <span data-ttu-id="c73b9-182">如果你使用的是 HP 回音 G2 控制器，则除 **InteractionSource** 以外的所有输入 api 都将继续工作，这将返回 false，而不会返回任何触摸板数据。</span><span class="sxs-lookup"><span data-stu-id="c73b9-182">If you're using HP Reverb G2 controllers, all input APIs will continue to work except for **InteractionSource.supportsTouchpad** , which will return false with no touchpad data.</span></span>

<span data-ttu-id="c73b9-183">有关详细信息，请参阅 [UNITYENGINE XR api 概述](../../unity/gestures-and-motion-controllers-in-unity.md#windows-specific-apis-xrwsainput)。</span><span class="sxs-lookup"><span data-stu-id="c73b9-183">For more information, see the [overview of the UnityEngine.XR.WSA.Input APIs](../../unity/gestures-and-motion-controllers-in-unity.md#windows-specific-apis-xrwsainput).</span></span>

## <a name="grip-pose-vs-pointing-pose"></a><span data-ttu-id="c73b9-184">手柄姿势与指针姿势</span><span class="sxs-lookup"><span data-stu-id="c73b9-184">Grip pose vs. pointing pose</span></span>

<span data-ttu-id="c73b9-185">Windows Mixed Reality 支持各种外形规格的运动控制器，其中每个控制器的设计在用户的手位置与应用程序在呈现控制器时应使用的自然 "前进" 方向不同。</span><span class="sxs-lookup"><span data-stu-id="c73b9-185">Windows Mixed Reality supports motion controllers in a variety of form factors, with each controller's design differing in its relationship between the user's hand position and the natural "forward" direction that apps should use for pointing when rendering the controller.</span></span>

<span data-ttu-id="c73b9-186">为了更好地表示这些控制器，可以针对每个交互源调查以下两种类型：</span><span class="sxs-lookup"><span data-stu-id="c73b9-186">To better represent these controllers, there are two kinds of poses you can investigate for each interaction source:</span></span>

* <span data-ttu-id="c73b9-187">**手柄姿势** ，表示由 HoloLens 检测到的掌托的位置，或包含运动控制器的掌托的位置。</span><span class="sxs-lookup"><span data-stu-id="c73b9-187">The **grip pose** , representing the location of either the palm of a hand detected by a HoloLens, or the palm holding a motion controller.</span></span>
    * <span data-ttu-id="c73b9-188">在沉浸式耳机上，这种姿势最适合用于呈现 **用户的手** 或 **持有用户的对象** ，例如剑或机枪。</span><span class="sxs-lookup"><span data-stu-id="c73b9-188">On immersive headsets, this pose is best used to render **the user's hand** or **an object held in the user's hand** , such as a sword or gun.</span></span>
    * <span data-ttu-id="c73b9-189">**手柄位置** ：在固定控制器时，掌上质心，向左或向右调整以使其在手柄内居中。</span><span class="sxs-lookup"><span data-stu-id="c73b9-189">The **grip position** : The palm centroid when holding the controller naturally, adjusted left or right to center the position within the grip.</span></span>
    * <span data-ttu-id="c73b9-190">**手柄方向的右轴** ：当你完全打开手形成一个平面的5指形姿势时，与你的掌上的光线 (从右手掌向后) </span><span class="sxs-lookup"><span data-stu-id="c73b9-190">The **grip orientation's Right axis** : When you completely open your hand to form a flat 5-finger pose, the ray that is normal to your palm (forward from left palm, backward from right palm)</span></span>
    * <span data-ttu-id="c73b9-191">**手柄方向的正向轴** ：当您关闭手中的部分 (时，就如同按住控制器) 一样，通过您的非拇指形来表示 "转发" 的射线。</span><span class="sxs-lookup"><span data-stu-id="c73b9-191">The **grip orientation's Forward axis** : When you close your hand partially (as if holding the controller), the ray that points "forward" through the tube formed by your non-thumb fingers.</span></span>
    * <span data-ttu-id="c73b9-192">**手柄方向的上轴** ：向右和向后定义隐含的上轴。</span><span class="sxs-lookup"><span data-stu-id="c73b9-192">The **grip orientation's Up axis** : The Up axis implied by the Right and Forward definitions.</span></span>
    * <span data-ttu-id="c73b9-193">可以通过 Unity 的跨供应商输入 API (XR 来访问抓握姿势 **[。InputTracking](https://docs.unity3d.com/ScriptReference/XR.InputTracking.html)。GetLocalPosition/旋转** ) 或通过特定于 Windows 的 API ( **sourcePose TryGetPosition/旋转** ，) 请求手柄姿势。</span><span class="sxs-lookup"><span data-stu-id="c73b9-193">You can access the grip pose through either Unity's cross-vendor input API ( **[XR.InputTracking](https://docs.unity3d.com/ScriptReference/XR.InputTracking.html).GetLocalPosition/Rotation** ) or through the Windows-specific API ( **sourceState.sourcePose.TryGetPosition/Rotation** , requesting the Grip pose).</span></span>
* <span data-ttu-id="c73b9-194">**指针姿势** ，表示控制器的末端。</span><span class="sxs-lookup"><span data-stu-id="c73b9-194">The **pointer pose** , representing the tip of the controller pointing forward.</span></span>
    * <span data-ttu-id="c73b9-195">这种姿势最适用于在呈现控制器模型本身时 **指向 UI** 时进行 raycast。</span><span class="sxs-lookup"><span data-stu-id="c73b9-195">This pose is best used to raycast when **pointing at UI** when you are rendering the controller model itself.</span></span>
    * <span data-ttu-id="c73b9-196">目前，指针姿势仅可通过特定于 Windows 的 API ( **TryGetPosition/旋转** ，请求指针) 。</span><span class="sxs-lookup"><span data-stu-id="c73b9-196">Currently, the pointer pose is available only through the Windows-specific API ( **sourceState.sourcePose.TryGetPosition/Rotation** , requesting the Pointer pose).</span></span>

<span data-ttu-id="c73b9-197">这些姿势坐标全部用 Unity 世界坐标表示。</span><span class="sxs-lookup"><span data-stu-id="c73b9-197">These pose coordinates are all expressed in Unity world coordinates.</span></span>
