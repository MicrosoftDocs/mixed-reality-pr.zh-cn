---
title: 尊敬的共享 250-HoloLens 和沉浸式耳机
description: 使用 Unity、Visual Studio、HoloLens 和 Windows Mixed Reality 耳机执行此编码演练，了解在混合现实设备之间共享全息影像的详细信息。
author: keveleigh
ms.author: kurtie
ms.date: 10/22/2019
ms.topic: article
keywords: holotoolkit、mixedrealitytoolkit、mixedrealitytoolkit-unity、沉浸式、运动控制器、共享、xbox 控制器、网络、跨设备
ms.openlocfilehash: 8b6711ab3ee833306742fe938dfa501dc5b4ed0e
ms.sourcegitcommit: d3a3b4f13b3728cfdd4d43035c806c0791d3f2fe
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/20/2021
ms.locfileid: "98580120"
---
# <a name="mr-sharing-250-hololens-and-immersive-headsets"></a><span data-ttu-id="0e15c-104">MR 共享 250：HoloLens 和沉浸式头戴显示设备</span><span class="sxs-lookup"><span data-stu-id="0e15c-104">MR Sharing 250: HoloLens and immersive headsets</span></span>

>[!NOTE]
><span data-ttu-id="0e15c-105">混合现实学院教程在制作时考虑到了 HoloLens（第一代）和混合现实沉浸式头戴显示设备。</span><span class="sxs-lookup"><span data-stu-id="0e15c-105">The Mixed Reality Academy tutorials were designed with HoloLens (1st gen) and Mixed Reality Immersive Headsets in mind.</span></span>  <span data-ttu-id="0e15c-106">因此，对于仍在寻求这些设备的开发指导的开发人员而言，我们觉得很有必要保留这些教程。</span><span class="sxs-lookup"><span data-stu-id="0e15c-106">As such, we feel it is important to leave these tutorials in place for developers who are still looking for guidance in developing for those devices.</span></span>  <span data-ttu-id="0e15c-107">我们 **不会** 在这些教程中更新 HoloLens 2 所用的最新工具集或集成相关的内容。</span><span class="sxs-lookup"><span data-stu-id="0e15c-107">These tutorials will **_not_** be updated with the latest toolsets or interactions being used for HoloLens 2.</span></span>  <span data-ttu-id="0e15c-108">我们将维护这些教程，使之持续适用于支持的设备。</span><span class="sxs-lookup"><span data-stu-id="0e15c-108">They will be maintained to continue working on the supported devices.</span></span> <span data-ttu-id="0e15c-109">已经为 HoloLens 2 发布了[一系列新教程](../develop/unity/tutorials/mr-learning-base-01.md)。</span><span class="sxs-lookup"><span data-stu-id="0e15c-109">[A new series of tutorials](../develop/unity/tutorials/mr-learning-base-01.md) has been posted for HoloLens 2.</span></span>

<span data-ttu-id="0e15c-110">利用通用 Windows 平台 (UWP) 的灵活性，可以轻松创建跨多个设备的应用程序。</span><span class="sxs-lookup"><span data-stu-id="0e15c-110">With the flexibility of Universal Windows Platform (UWP), it is easy to create an application that spans multiple devices.</span></span> <span data-ttu-id="0e15c-111">通过这种灵活性，我们可以创建利用每个设备的优势的体验。</span><span class="sxs-lookup"><span data-stu-id="0e15c-111">With this flexibility, we can create experiences that leverage the strengths of each device.</span></span> <span data-ttu-id="0e15c-112">本教程将介绍在 HoloLens 和 Windows Mixed Reality 沉浸式耳机上运行的基本共享体验。</span><span class="sxs-lookup"><span data-stu-id="0e15c-112">This tutorial will cover a basic shared experience that runs on both HoloLens and Windows Mixed Reality immersive headsets.</span></span> <span data-ttu-id="0e15c-113">此内容最初在华盛顿州西雅图的 Microsoft Build 2017 大会上交付。</span><span class="sxs-lookup"><span data-stu-id="0e15c-113">This content was originally delivered at the Microsoft Build 2017 conference in Seattle, WA.</span></span>

<span data-ttu-id="0e15c-114">**在本教程中，我们将：**</span><span class="sxs-lookup"><span data-stu-id="0e15c-114">**In this tutorial, we will:**</span></span>

* <span data-ttu-id="0e15c-115">使用 UNET 设置网络。</span><span class="sxs-lookup"><span data-stu-id="0e15c-115">Setup a network using UNET.</span></span>
* <span data-ttu-id="0e15c-116">跨混合现实设备共享全息影像。</span><span class="sxs-lookup"><span data-stu-id="0e15c-116">Share holograms across mixed reality devices.</span></span>
* <span data-ttu-id="0e15c-117">根据正在使用的混合现实设备，建立不同的应用程序视图。</span><span class="sxs-lookup"><span data-stu-id="0e15c-117">Establish a different view of the application depending on which mixed reality device is being used.</span></span>
* <span data-ttu-id="0e15c-118">通过一些简单的测验题，为 HoloLens 用户指导沉浸式耳机用户。</span><span class="sxs-lookup"><span data-stu-id="0e15c-118">Create a shared experience where HoloLens users guide immersive headsets users through some simple puzzles.</span></span>

## <a name="device-support"></a><span data-ttu-id="0e15c-119">设备支持</span><span class="sxs-lookup"><span data-stu-id="0e15c-119">Device support</span></span>

<table>
<tr>
<th><span data-ttu-id="0e15c-120">课程</span><span class="sxs-lookup"><span data-stu-id="0e15c-120">Course</span></span></th><th style="width:150px"> <span data-ttu-id="0e15c-121"><a href="/hololens/hololens1-hardware">HoloLens</a></span><span class="sxs-lookup"><span data-stu-id="0e15c-121"><a href="/hololens/hololens1-hardware">HoloLens</a></span></span></th><th style="width:150px"> <span data-ttu-id="0e15c-122"><a href="../discover/immersive-headset-hardware-details.md">沉浸式头戴显示设备</a></span><span class="sxs-lookup"><span data-stu-id="0e15c-122"><a href="../discover/immersive-headset-hardware-details.md">Immersive headsets</a></span></span></th>
</tr><tr>
<td><span data-ttu-id="0e15c-123">MR 共享 250：HoloLens 和沉浸式头戴显示设备</span><span class="sxs-lookup"><span data-stu-id="0e15c-123">MR Sharing 250: HoloLens and immersive headsets</span></span></td><td style="text-align: center;"> <span data-ttu-id="0e15c-124">✔️</span><span class="sxs-lookup"><span data-stu-id="0e15c-124">✔️</span></span></td><td style="text-align: center;"> <span data-ttu-id="0e15c-125">✔️</span><span class="sxs-lookup"><span data-stu-id="0e15c-125">✔️</span></span></td>
</tr>
</table>

## <a name="before-you-start"></a><span data-ttu-id="0e15c-126">准备工作</span><span class="sxs-lookup"><span data-stu-id="0e15c-126">Before you start</span></span>

### <a name="prerequisites"></a><span data-ttu-id="0e15c-127">必备条件</span><span class="sxs-lookup"><span data-stu-id="0e15c-127">Prerequisites</span></span>

* <span data-ttu-id="0e15c-128">带有 [必要的开发工具](../develop/install-the-tools.md) 且 [已配置为支持 windows Mixed Reality 沉浸式耳机](/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines)的 Windows 10 电脑。</span><span class="sxs-lookup"><span data-stu-id="0e15c-128">A Windows 10 PC with the [necessary development tools](../develop/install-the-tools.md) and [configured to support a Windows Mixed Reality immersive headset](/windows/mixed-reality/enthusiast-guide/windows-mixed-reality-minimum-pc-hardware-compatibility-guidelines).</span></span>
* <span data-ttu-id="0e15c-129">适用于你的电脑的 Xbox 控制器。</span><span class="sxs-lookup"><span data-stu-id="0e15c-129">An Xbox controller that works with your PC.</span></span>
* <span data-ttu-id="0e15c-130">至少一个 HoloLens 设备和一个沉浸式耳机。</span><span class="sxs-lookup"><span data-stu-id="0e15c-130">At least one HoloLens device and one immersive headset.</span></span>
* <span data-ttu-id="0e15c-131">允许 UDP 广播进行发现的网络。</span><span class="sxs-lookup"><span data-stu-id="0e15c-131">A network which allows UDP Broadcast for discovery.</span></span>

### <a name="project-files"></a><span data-ttu-id="0e15c-132">项目文件</span><span class="sxs-lookup"><span data-stu-id="0e15c-132">Project files</span></span>

* <span data-ttu-id="0e15c-133">下载项目所需的 [文件](https://github.com/Microsoft/MixedReality250/archive/master.zip) 。</span><span class="sxs-lookup"><span data-stu-id="0e15c-133">Download the [files](https://github.com/Microsoft/MixedReality250/archive/master.zip) required by the project.</span></span> <span data-ttu-id="0e15c-134">将文件提取到易于记忆的位置。</span><span class="sxs-lookup"><span data-stu-id="0e15c-134">Extract the files to an easy to remember location.</span></span>
* <span data-ttu-id="0e15c-135">此项目需要 [具有 Windows Mixed Reality 支持的推荐版本的 Unity](../develop/install-the-tools.md)。</span><span class="sxs-lookup"><span data-stu-id="0e15c-135">This project requires the [a recommended version of Unity with Windows Mixed Reality support](../develop/install-the-tools.md).</span></span>

>[!NOTE]
><span data-ttu-id="0e15c-136">如果要在下载之前查看源代码， [可在 GitHub 上](https://github.com/Microsoft/MixedReality250)找到。</span><span class="sxs-lookup"><span data-stu-id="0e15c-136">If you want to look through the source code before downloading, it's [available on GitHub](https://github.com/Microsoft/MixedReality250).</span></span>

## <a name="chapter-1---holo-world"></a><span data-ttu-id="0e15c-137">第1章-Holo World</span><span class="sxs-lookup"><span data-stu-id="0e15c-137">Chapter 1 - Holo World</span></span>

>[!VIDEO https://www.youtube.com/embed/IC0rp6rLiEc]

### <a name="objectives"></a><span data-ttu-id="0e15c-138">目标</span><span class="sxs-lookup"><span data-stu-id="0e15c-138">Objectives</span></span>

<span data-ttu-id="0e15c-139">请确保开发环境已准备好使用简单项目。</span><span class="sxs-lookup"><span data-stu-id="0e15c-139">Make sure the development environment is ready to go with a simple project.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="0e15c-140">要生成的内容</span><span class="sxs-lookup"><span data-stu-id="0e15c-140">What we will build</span></span>

<span data-ttu-id="0e15c-141">在 HoloLens 或 Windows Mixed Reality 沉浸式耳机上显示全息图的应用程序。</span><span class="sxs-lookup"><span data-stu-id="0e15c-141">An application that shows a hologram on either HoloLens or a Windows Mixed Reality immersive headset.</span></span>

### <a name="steps"></a><span data-ttu-id="0e15c-142">步骤</span><span class="sxs-lookup"><span data-stu-id="0e15c-142">Steps</span></span>

* <span data-ttu-id="0e15c-143">打开 Unity。</span><span class="sxs-lookup"><span data-stu-id="0e15c-143">Open Unity.</span></span>
    * <span data-ttu-id="0e15c-144">选择“打开”  。</span><span class="sxs-lookup"><span data-stu-id="0e15c-144">Select **Open**.</span></span>
    * <span data-ttu-id="0e15c-145">导航到在其中提取项目文件的位置。</span><span class="sxs-lookup"><span data-stu-id="0e15c-145">Navigate to where you extracted the project files.</span></span>
    * <span data-ttu-id="0e15c-146">单击“选择文件夹”。</span><span class="sxs-lookup"><span data-stu-id="0e15c-146">Click **Select Folder**.</span></span>
    * <span data-ttu-id="0e15c-147">*Unity 第一次处理项目需要一些时间。*</span><span class="sxs-lookup"><span data-stu-id="0e15c-147">*It will take a little while for Unity to process the project the first time.*</span></span>
* <span data-ttu-id="0e15c-148">检查 Unity 中是否已启用混合现实。</span><span class="sxs-lookup"><span data-stu-id="0e15c-148">Check that Mixed Reality is enabled in Unity.</span></span>
    * <span data-ttu-id="0e15c-149">打开 "生成设置" 对话框 (**Control + Shift + B** 或 **> 生成设置 ...**) "。</span><span class="sxs-lookup"><span data-stu-id="0e15c-149">Open the build settings dialog (**Control+Shift+B** or **File > Build Settings...**).</span></span>
    * <span data-ttu-id="0e15c-150">选择 **通用 Windows 平台** 然后单击 " **切换平台**"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-150">Select **Universal Windows Platform** then click **Switch Platform**.</span></span>
    * <span data-ttu-id="0e15c-151">选择 " **编辑>播放机设置**"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-151">Select **Edit>Player Settings**.</span></span>
    * <span data-ttu-id="0e15c-152">在右侧的 **检查器** 面板中，展开 " **XR 设置**"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-152">In the **Inspector** panel on the right hand side, expand **XR Settings**.</span></span>
    * <span data-ttu-id="0e15c-153">选中 " **支持虚拟现实** " 框。</span><span class="sxs-lookup"><span data-stu-id="0e15c-153">Check the **Virtual Reality Supported** box.</span></span>
    * <span data-ttu-id="0e15c-154">*Windows Mixed Reality 应为虚拟现实 SDK。*</span><span class="sxs-lookup"><span data-stu-id="0e15c-154">*Windows Mixed Reality should be the Virtual Reality SDK.*</span></span>
* <span data-ttu-id="0e15c-155">创建场景。</span><span class="sxs-lookup"><span data-stu-id="0e15c-155">Create a scene.</span></span>
    * <span data-ttu-id="0e15c-156">在 **层次结构** 中右键单击 " **主相机** "，然后选择 " **删除**"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-156">In the **Hierarchy** right click **Main Camera** select **Delete**.</span></span>
    * <span data-ttu-id="0e15c-157">从 **HoloToolkit > 输入 > prototyping** 将 **MixedRealityCameraParent** 拖到 **层次结构** 中。</span><span class="sxs-lookup"><span data-stu-id="0e15c-157">From **HoloToolkit > Input > Prefabs** drag **MixedRealityCameraParent** to the **Hierarchy**.</span></span>
* <span data-ttu-id="0e15c-158">向场景中添加全息影像</span><span class="sxs-lookup"><span data-stu-id="0e15c-158">Add Holograms to the scene</span></span>
    * <span data-ttu-id="0e15c-159">From **AppPrefabs** 将 **Skybox** 拖到 **场景视图**。</span><span class="sxs-lookup"><span data-stu-id="0e15c-159">From **AppPrefabs** drag **Skybox** to the **Scene View**.</span></span>
    * <span data-ttu-id="0e15c-160">From **AppPrefabs** 将 **经理** 拖到 **层次结构** 中。</span><span class="sxs-lookup"><span data-stu-id="0e15c-160">From **AppPrefabs** drag **Managers** to the **Hierarchy**.</span></span>
    * <span data-ttu-id="0e15c-161">From **AppPrefabs** 将 **岛** 拖到 **层次结构** 中。</span><span class="sxs-lookup"><span data-stu-id="0e15c-161">From **AppPrefabs** drag **Island** to the **Hierarchy**.</span></span>
* <span data-ttu-id="0e15c-162">保存并生成</span><span class="sxs-lookup"><span data-stu-id="0e15c-162">Save And build</span></span>
    * <span data-ttu-id="0e15c-163">保存 (**Control + S** 或 **File > save 场景**) </span><span class="sxs-lookup"><span data-stu-id="0e15c-163">Save (either **Control+S** or **File > Save Scene**)</span></span>
    * <span data-ttu-id="0e15c-164">由于这是新场景，因此需要将其命名为。</span><span class="sxs-lookup"><span data-stu-id="0e15c-164">Since this is a new scene, you'll need to name it.</span></span> <span data-ttu-id="0e15c-165">名称并不重要，但我们使用的是 SharedMixedReality。</span><span class="sxs-lookup"><span data-stu-id="0e15c-165">Name doesn't matter, but we use SharedMixedReality.</span></span>
* <span data-ttu-id="0e15c-166">导出到 Visual Studio</span><span class="sxs-lookup"><span data-stu-id="0e15c-166">Export To Visual Studio</span></span>
    * <span data-ttu-id="0e15c-167">打开 "生成" 菜单 (**Control + Shift + B** 或 **File > 生成设置** ") </span><span class="sxs-lookup"><span data-stu-id="0e15c-167">Open the build menu (**Control+Shift+B** or **File > Build Settings**)</span></span>
    * <span data-ttu-id="0e15c-168">单击 " **添加打开的场景"。**</span><span class="sxs-lookup"><span data-stu-id="0e15c-168">Click **Add Open Scenes.**</span></span>
    * <span data-ttu-id="0e15c-169">检查 **Unity c # 项目**</span><span class="sxs-lookup"><span data-stu-id="0e15c-169">Check **Unity C# Projects**</span></span>
    * <span data-ttu-id="0e15c-170">单击“生成”。</span><span class="sxs-lookup"><span data-stu-id="0e15c-170">Click **Build**.</span></span>
    * <span data-ttu-id="0e15c-171">在出现的 "文件资源管理器" 窗口中，创建一个名为 " **应用**" 的新文件夹。</span><span class="sxs-lookup"><span data-stu-id="0e15c-171">In the file explorer window that appears, create a New Folder named **App**.</span></span>
    * <span data-ttu-id="0e15c-172">单击 **应用** 文件夹。</span><span class="sxs-lookup"><span data-stu-id="0e15c-172">Single click the **App** folder.</span></span>
    * <span data-ttu-id="0e15c-173">按 " **选择文件夹"。**</span><span class="sxs-lookup"><span data-stu-id="0e15c-173">Press **Select Folder.**</span></span>
    * <span data-ttu-id="0e15c-174">**等待生成完成**</span><span class="sxs-lookup"><span data-stu-id="0e15c-174">**Wait for the build to complete**</span></span>
    * <span data-ttu-id="0e15c-175">在出现的 "文件资源管理器" 窗口中，导航到 " **应用** " 文件夹。</span><span class="sxs-lookup"><span data-stu-id="0e15c-175">In the file explorer window that appears, navigate into the **App** folder.</span></span>
    * <span data-ttu-id="0e15c-176">双击 " **SharedMixedReality** " 以启动 Visual Studio</span><span class="sxs-lookup"><span data-stu-id="0e15c-176">Double-click **SharedMixedReality.sln** to launch Visual Studio</span></span>
* <span data-ttu-id="0e15c-177">从 Visual Studio 生成</span><span class="sxs-lookup"><span data-stu-id="0e15c-177">Build From Visual Studio</span></span>
    * <span data-ttu-id="0e15c-178">使用顶部工具栏将目标更改为 " **发布** " 和 " **x86**"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-178">Using the top toolbar change target to **Release** and **x86**.</span></span>
    * <span data-ttu-id="0e15c-179">单击 " **本地计算机** " 旁边的箭头，并选择 "要部署到 HoloLens 的 **设备** "</span><span class="sxs-lookup"><span data-stu-id="0e15c-179">Click the arrow next to **Local Machine** and select **Device** to deploy to HoloLens</span></span>
    * <span data-ttu-id="0e15c-180">单击 " **设备** " 旁边的箭头，并选择 "要为混合现实耳机部署的 **本地计算机** "。</span><span class="sxs-lookup"><span data-stu-id="0e15c-180">Click the arrow next to **Device** and select **Local Machine** to deploy for the mixed reality headset.</span></span>
    * <span data-ttu-id="0e15c-181">单击 " **调试"->"无调试开始** " 或按 **F5** 启动应用程序。</span><span class="sxs-lookup"><span data-stu-id="0e15c-181">Click **Debug->Start Without Debugging** or **Control+F5** to start the application.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="0e15c-182">深入到代码中</span><span class="sxs-lookup"><span data-stu-id="0e15c-182">Digging into the code</span></span>

<span data-ttu-id="0e15c-183">在 "项目" 面板中，导航到 " **Assets\HoloToolkit\Input\Scripts\Utilities** "，然后双击 " **MixedRealityCameraManager.cs** " 将其打开。</span><span class="sxs-lookup"><span data-stu-id="0e15c-183">In the project panel, navigate to **Assets\HoloToolkit\Input\Scripts\Utilities** and double click **MixedRealityCameraManager.cs** to open it.</span></span>

<span data-ttu-id="0e15c-184">**概述：** MixedRealityCameraManager.cs 是一个简单的脚本，可根据设备调整质量级别和背景设置。</span><span class="sxs-lookup"><span data-stu-id="0e15c-184">**Overview:** MixedRealityCameraManager.cs is a simple script that adjusts quality level and background settings based on the device.</span></span> <span data-ttu-id="0e15c-185">此处的密钥为 HolographicSettings。 IsDisplayOpaque，它允许脚本检测设备是否为 HoloLens (IsDisplayOpaque 返回 false) 或沉浸式耳机 (IsDisplayOpaque 返回 true) 。</span><span class="sxs-lookup"><span data-stu-id="0e15c-185">Key here is HolographicSettings.IsDisplayOpaque, which allows a script to detect if the device is a HoloLens (IsDisplayOpaque returns false) or an immersive headset (IsDisplayOpaque returns true).</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="0e15c-186">欣赏你的进度</span><span class="sxs-lookup"><span data-stu-id="0e15c-186">Enjoy your progress</span></span>

<span data-ttu-id="0e15c-187">此时，应用程序将只呈现一个全息图。</span><span class="sxs-lookup"><span data-stu-id="0e15c-187">At this point the application will just render a hologram.</span></span> <span data-ttu-id="0e15c-188">稍后我们将向全息图添加交互。</span><span class="sxs-lookup"><span data-stu-id="0e15c-188">We will add interaction to the hologram later.</span></span> <span data-ttu-id="0e15c-189">这两个设备会将两个全息图呈现相同的。</span><span class="sxs-lookup"><span data-stu-id="0e15c-189">Both devices will render the hologram the same.</span></span> <span data-ttu-id="0e15c-190">沉浸式耳机还会呈现蓝天和云背景。</span><span class="sxs-lookup"><span data-stu-id="0e15c-190">The immersive headset will also render a blue sky and clouds background.</span></span>

## <a name="chapter-2---interaction"></a><span data-ttu-id="0e15c-191">第2章-交互</span><span class="sxs-lookup"><span data-stu-id="0e15c-191">Chapter 2 - Interaction</span></span>

>[!VIDEO https://www.youtube.com/embed/Lrb1y4sQRvI]

### <a name="objectives"></a><span data-ttu-id="0e15c-192">目标</span><span class="sxs-lookup"><span data-stu-id="0e15c-192">Objectives</span></span>

<span data-ttu-id="0e15c-193">演示如何处理 Windows Mixed Reality 应用程序的输入。</span><span class="sxs-lookup"><span data-stu-id="0e15c-193">Show how to handle input for a Windows Mixed Reality application.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="0e15c-194">要生成的内容</span><span class="sxs-lookup"><span data-stu-id="0e15c-194">What we will build</span></span>

<span data-ttu-id="0e15c-195">基于第1章中的应用程序，我们将添加功能，使用户能够选择全息影像，并将其放在 HoloLens 的真实表面上，或将其放置在沉浸式耳机中的虚拟表上。</span><span class="sxs-lookup"><span data-stu-id="0e15c-195">Building on the application from chapter 1, we will add functionality to allow the user to pick up the hologram and place it on a real world surface in HoloLens or on a virtual table in an immersive headset.</span></span>

<span data-ttu-id="0e15c-196">**输入刷新器：** 在 HoloLens 上，选择手势是 **点击**。</span><span class="sxs-lookup"><span data-stu-id="0e15c-196">**Input Refresher:** On HoloLens the select gesture is the **air tap**.</span></span> <span data-ttu-id="0e15c-197">在沉浸式耳机上，我们将使用 Xbox 控制器上 **的按钮。**</span><span class="sxs-lookup"><span data-stu-id="0e15c-197">On immersive headsets, we will use the **A** button on the Xbox controller.</span></span> <span data-ttu-id="0e15c-198">有关详细信息，请查看 [交互模型概述](../design/interaction-fundamentals.md)。</span><span class="sxs-lookup"><span data-stu-id="0e15c-198">For more information check out the [interaction model overview](../design/interaction-fundamentals.md).</span></span>

### <a name="steps"></a><span data-ttu-id="0e15c-199">步骤</span><span class="sxs-lookup"><span data-stu-id="0e15c-199">Steps</span></span>

* <span data-ttu-id="0e15c-200">添加输入管理器</span><span class="sxs-lookup"><span data-stu-id="0e15c-200">Add Input manager</span></span>
    * <span data-ttu-id="0e15c-201">从 **HoloToolkit > 输入 > prototyping** 将 **InputManager** 作为 **经理** 的子项拖到 **层次结构** 中。</span><span class="sxs-lookup"><span data-stu-id="0e15c-201">From **HoloToolkit > Input > Prefabs** drag **InputManager** to **Hierarchy** as a child of **Managers**.</span></span>
    * <span data-ttu-id="0e15c-202">从 **HoloToolkit > 输入 > prototyping > 光标** 将 **光标** 拖到 **层次结构** 中。</span><span class="sxs-lookup"><span data-stu-id="0e15c-202">From **HoloToolkit > Input > Prefabs > Cursor** drag **Cursor** to **Hierarchy**.</span></span>
* <span data-ttu-id="0e15c-203">添加空间映射</span><span class="sxs-lookup"><span data-stu-id="0e15c-203">Add Spatial Mapping</span></span>
    * <span data-ttu-id="0e15c-204">From **HoloToolkit > SpatialMapping > prototyping** 将 **SpatialMapping** 拖到 **层次结构** 中。</span><span class="sxs-lookup"><span data-stu-id="0e15c-204">From **HoloToolkit > SpatialMapping > Prefabs** drag **SpatialMapping** to **Hierarchy**.</span></span>
* <span data-ttu-id="0e15c-205">添加虚拟 Playspace</span><span class="sxs-lookup"><span data-stu-id="0e15c-205">Add Virtual Playspace</span></span>
    * <span data-ttu-id="0e15c-206">在 **层次结构** 中展开 **MixedRealityCameraParent** 选择 **边界**</span><span class="sxs-lookup"><span data-stu-id="0e15c-206">In **Hierarchy** expand **MixedRealityCameraParent** select **Boundary**</span></span>
    * <span data-ttu-id="0e15c-207">检查 **器** 面板中的复选框以启用 **边界**</span><span class="sxs-lookup"><span data-stu-id="0e15c-207">In **Inspector** panel check the box to enable **Boundary**</span></span>
    * <span data-ttu-id="0e15c-208">From **AppPrefabs** 将 **VRRoom** 拖到 **层次结构** 中。</span><span class="sxs-lookup"><span data-stu-id="0e15c-208">From **AppPrefabs** drag **VRRoom** to **Hierarchy**.</span></span>
* <span data-ttu-id="0e15c-209">添加 WorldAnchorManager</span><span class="sxs-lookup"><span data-stu-id="0e15c-209">Add WorldAnchorManager</span></span>
    * <span data-ttu-id="0e15c-210">在 **层次结构** 中，选择 " **管理器**"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-210">In **Hierarchy**, Select **Managers**.</span></span>
    * <span data-ttu-id="0e15c-211">在 **检查器** 中，单击 " **添加组件**"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-211">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="0e15c-212">键入 " **世界定位管理器**"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-212">Type **World Anchor Manager**.</span></span>
    * <span data-ttu-id="0e15c-213">选择 " **世界锚管理器** " 以添加它。</span><span class="sxs-lookup"><span data-stu-id="0e15c-213">Select **World Anchor Manager** to add it.</span></span>
* <span data-ttu-id="0e15c-214">将 TapToPlace 添加到岛</span><span class="sxs-lookup"><span data-stu-id="0e15c-214">Add TapToPlace to the Island</span></span>
    * <span data-ttu-id="0e15c-215">在 **层次结构** 中，展开 " **岛**"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-215">In **Hierarchy**, expand **Island**.</span></span>
    * <span data-ttu-id="0e15c-216">选择 **MixedRealityLand**。</span><span class="sxs-lookup"><span data-stu-id="0e15c-216">Select **MixedRealityLand**.</span></span>
    * <span data-ttu-id="0e15c-217">在 **检查器** 中，单击 " **添加组件**"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-217">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="0e15c-218">键入 " **点击" 以将** 其选中。</span><span class="sxs-lookup"><span data-stu-id="0e15c-218">Type **Tap To Place** and select it.</span></span>
    * <span data-ttu-id="0e15c-219">**在点击时选中 "父项"**。</span><span class="sxs-lookup"><span data-stu-id="0e15c-219">Check **Place Parent On Tap**.</span></span>
    * <span data-ttu-id="0e15c-220">将 **放置偏移** 设置为 **(0，0.1，0)**。</span><span class="sxs-lookup"><span data-stu-id="0e15c-220">Set **Placement Offset** to **(0, 0.1, 0)**.</span></span>
* <span data-ttu-id="0e15c-221">像以前一样保存并生成</span><span class="sxs-lookup"><span data-stu-id="0e15c-221">Save and Build as before</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="0e15c-222">深入到代码中</span><span class="sxs-lookup"><span data-stu-id="0e15c-222">Digging into the code</span></span>

<span data-ttu-id="0e15c-223">**脚本 1-GamepadInput.cs**</span><span class="sxs-lookup"><span data-stu-id="0e15c-223">**Script 1 - GamepadInput.cs**</span></span>

<span data-ttu-id="0e15c-224">在 "项目" 面板中，导航到 " **Assets\HoloToolkit\Input\Scripts\InputSources** "，然后双击 " **GamepadInput.cs** " 将其打开。</span><span class="sxs-lookup"><span data-stu-id="0e15c-224">In the project panel navigate to **Assets\HoloToolkit\Input\Scripts\InputSources** and double click **GamepadInput.cs** to open it.</span></span> <span data-ttu-id="0e15c-225">在 "项目" 面板的同一路径中，双击 " **InteractionSourceInputSource.cs**"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-225">From the same path in the project panel, also double click **InteractionSourceInputSource.cs**.</span></span>

<span data-ttu-id="0e15c-226">请注意，这两个脚本都有一个公共的基类 BaseInputSource。</span><span class="sxs-lookup"><span data-stu-id="0e15c-226">Note that both scripts have a common base class, BaseInputSource.</span></span>

<span data-ttu-id="0e15c-227">BaseInputSource 保留对 InputManager 的引用，这允许脚本触发事件。</span><span class="sxs-lookup"><span data-stu-id="0e15c-227">BaseInputSource keeps a reference to an InputManager, which allows a script to trigger events.</span></span> <span data-ttu-id="0e15c-228">在这种情况下，InputClicked 事件是相关的。</span><span class="sxs-lookup"><span data-stu-id="0e15c-228">In this case, the InputClicked event is relevant.</span></span> <span data-ttu-id="0e15c-229">当我们进入脚本 2 TapToPlace 时，请务必记住这一点。</span><span class="sxs-lookup"><span data-stu-id="0e15c-229">This will be important to remember when we get to script 2, TapToPlace.</span></span> <span data-ttu-id="0e15c-230">对于 GamePadInput，我们轮询控制器上要按下的按钮，然后引发 InputClicked 事件。</span><span class="sxs-lookup"><span data-stu-id="0e15c-230">In the case of GamePadInput, we poll for the A button on the controller to be pressed, then we raise the InputClicked event.</span></span> <span data-ttu-id="0e15c-231">对于 InteractionSourceInputSource，我们将引发 InputClicked 事件以响应 TappedEvent。</span><span class="sxs-lookup"><span data-stu-id="0e15c-231">In the case of InteractionSourceInputSource, we raise the InputClicked event in response to the TappedEvent.</span></span>

<span data-ttu-id="0e15c-232">**脚本 2-TapToPlace.cs**</span><span class="sxs-lookup"><span data-stu-id="0e15c-232">**Script 2 - TapToPlace.cs**</span></span>

<span data-ttu-id="0e15c-233">在 "项目" 面板中，导航到 " **Assets\HoloToolkit\SpatialMapping\Scripts** "，然后双击 " **TapToPlace.cs** " 将其打开。</span><span class="sxs-lookup"><span data-stu-id="0e15c-233">In the project panel navigate to **Assets\HoloToolkit\SpatialMapping\Scripts** and double click **TapToPlace.cs** to open it.</span></span>

<span data-ttu-id="0e15c-234">许多开发人员在创建全息应用程序时要实现的第一件事是使用手势输入来移动全息影像。</span><span class="sxs-lookup"><span data-stu-id="0e15c-234">The first thing many developers want to implement when creating a Holographic application is moving Holograms with gesture input.</span></span> <span data-ttu-id="0e15c-235">同样，我们已 endeavored 对此脚本进行全面注释。</span><span class="sxs-lookup"><span data-stu-id="0e15c-235">As such, we've endeavored to thoroughly comment this script.</span></span> <span data-ttu-id="0e15c-236">对于本教程，有几个值得注意的事项。</span><span class="sxs-lookup"><span data-stu-id="0e15c-236">A few things are worth highlighting for this tutorial.</span></span>

<span data-ttu-id="0e15c-237">首先，请注意，TapToPlace 实现了 IInputClickHandler。</span><span class="sxs-lookup"><span data-stu-id="0e15c-237">First, note that TapToPlace implements IInputClickHandler.</span></span> <span data-ttu-id="0e15c-238">IInputClickHandler 公开处理 GamePadInput.cs 或 InteractionSourceInputSource.cs 引发的 InputClicked 事件的函数。</span><span class="sxs-lookup"><span data-stu-id="0e15c-238">IInputClickHandler exposes the functions that handle the InputClicked event raised by GamePadInput.cs or InteractionSourceInputSource.cs.</span></span> <span data-ttu-id="0e15c-239">当 BaseInputSource 检测到具有 TapToPlace 的对象时，将调用 OnInputClicked。</span><span class="sxs-lookup"><span data-stu-id="0e15c-239">OnInputClicked is called when a BaseInputSource detects a click while the object with TapToPlace is in focus.</span></span> <span data-ttu-id="0e15c-240">在 HoloLens 上 airtapping 或按下 Xbox 控制器上的一个按钮将触发该事件。</span><span class="sxs-lookup"><span data-stu-id="0e15c-240">Either airtapping on HoloLens or pressing the A button on the Xbox controller will trigger the event.</span></span>

<span data-ttu-id="0e15c-241">第二是在更新中执行代码以查看是否正在查看某个面，以便我们可以将游戏对象放置在图面上，如表。</span><span class="sxs-lookup"><span data-stu-id="0e15c-241">Second is the code be executed in update to see if a surface is being looked at so we can place the game object on a surface, like a table.</span></span> <span data-ttu-id="0e15c-242">沉浸式头戴式耳机没有实表面的概念，因此表示表顶部 (Vroom > TableThingy > 多维数据集) 的对象已使用 SpatialMapping 物理学层进行标记，因此更新中的 ray 转换将与虚拟表的顶部发生冲突。</span><span class="sxs-lookup"><span data-stu-id="0e15c-242">The immersive headset doesn't have a concept of real surfaces, so the object that represents the table top (Vroom > TableThingy > Cube) has been marked with the SpatialMapping physics layer, so the ray cast in Update will collide with the virtual table top.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="0e15c-243">欣赏你的进度</span><span class="sxs-lookup"><span data-stu-id="0e15c-243">Enjoy your progress</span></span>

<span data-ttu-id="0e15c-244">这一次，您可以选择要移动的岛。</span><span class="sxs-lookup"><span data-stu-id="0e15c-244">This time you can select the island to move it.</span></span> <span data-ttu-id="0e15c-245">在 HoloLens 上，你可以将岛移动到真实表面。</span><span class="sxs-lookup"><span data-stu-id="0e15c-245">On HoloLens you can move the island to a real surface.</span></span> <span data-ttu-id="0e15c-246">在沉浸式耳机中，你可以将岛移动到我们添加的虚拟表。</span><span class="sxs-lookup"><span data-stu-id="0e15c-246">In the immersive headset you can move the island to the virtual table we added.</span></span>

## <a name="chapter-3---sharing"></a><span data-ttu-id="0e15c-247">第3章-共享</span><span class="sxs-lookup"><span data-stu-id="0e15c-247">Chapter 3 - Sharing</span></span>

>[!VIDEO https://www.youtube.com/embed/1diycJvxfDc]

### <a name="objectives"></a><span data-ttu-id="0e15c-248">目标</span><span class="sxs-lookup"><span data-stu-id="0e15c-248">Objectives</span></span>

<span data-ttu-id="0e15c-249">确保已正确配置网络，并详细说明如何在设备之间共享空间锚。</span><span class="sxs-lookup"><span data-stu-id="0e15c-249">Ensure that the network is correctly configured and detail how spatial anchors are shared between devices.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="0e15c-250">要生成的内容</span><span class="sxs-lookup"><span data-stu-id="0e15c-250">What we will build</span></span>

<span data-ttu-id="0e15c-251">我们会将项目转换为多玩家项目。</span><span class="sxs-lookup"><span data-stu-id="0e15c-251">We will convert our project to a multiplayer project.</span></span> <span data-ttu-id="0e15c-252">我们会将 UI 和逻辑添加到主机或加入会话。</span><span class="sxs-lookup"><span data-stu-id="0e15c-252">We will add UI and logic to host or join sessions.</span></span> <span data-ttu-id="0e15c-253">HoloLens 用户会在会话中使用其打印头上的云查看彼此，并且沉浸式头戴式耳机用户在锚定到的位置附近有云。</span><span class="sxs-lookup"><span data-stu-id="0e15c-253">HoloLens users will see each other in the session with clouds over their heads, and immersive headset users have clouds near to where the anchor is.</span></span> <span data-ttu-id="0e15c-254">沉浸式耳机中的用户将看到 HoloLens 用户相对场景的原点。</span><span class="sxs-lookup"><span data-stu-id="0e15c-254">Users in the immersive headsets will see the HoloLens users relative to the origin of the scene.</span></span> <span data-ttu-id="0e15c-255">HoloLens 用户将在同一位置看到岛的全息影像。</span><span class="sxs-lookup"><span data-stu-id="0e15c-255">HoloLens users will all see the hologram of the island in the same place.</span></span> <span data-ttu-id="0e15c-256">需要注意的是，沉浸式耳机中的用户将不会在本章节中的岛上出现，但会表现得非常类似于 HoloLens，并具有岛的鸟瞰视图。</span><span class="sxs-lookup"><span data-stu-id="0e15c-256">It is key to note that the users in the immersive headsets will not be on the island during this chapter, but will behave very similarly to HoloLens, with a birds eye view of the island.</span></span>

### <a name="steps"></a><span data-ttu-id="0e15c-257">步骤</span><span class="sxs-lookup"><span data-stu-id="0e15c-257">Steps</span></span>

* <span data-ttu-id="0e15c-258">删除岛和 VRRoom</span><span class="sxs-lookup"><span data-stu-id="0e15c-258">Remove Island and VRRoom</span></span>
    * <span data-ttu-id="0e15c-259">在 **层次结构** 中右键单击 **岛** 选择 **删除**</span><span class="sxs-lookup"><span data-stu-id="0e15c-259">In **Hierarchy** right-click **Island** select **Delete**</span></span>
    * <span data-ttu-id="0e15c-260">在 **层次结构** 中右键单击 **VRRoom** 选择 **删除**</span><span class="sxs-lookup"><span data-stu-id="0e15c-260">In **Hierarchy** right-click **VRRoom** select **Delete**</span></span>
* <span data-ttu-id="0e15c-261">添加 Usland</span><span class="sxs-lookup"><span data-stu-id="0e15c-261">Add Usland</span></span>
    * <span data-ttu-id="0e15c-262">From **AppPrefabs** 将 **Usland** 拖到 **层次结构** 中。</span><span class="sxs-lookup"><span data-stu-id="0e15c-262">From **AppPrefabs** drag **Usland** to **Hierarchy**.</span></span>
* <span data-ttu-id="0e15c-263">从 **AppPrefabs** 将以下各项拖动到 **层次结构**：</span><span class="sxs-lookup"><span data-stu-id="0e15c-263">From **AppPrefabs** drag each of the following to **Hierarchy**:</span></span>
    * <span data-ttu-id="0e15c-264">**UNETSharingStage**</span><span class="sxs-lookup"><span data-stu-id="0e15c-264">**UNETSharingStage**</span></span>
    * <span data-ttu-id="0e15c-265">**UNetAnchorRoot**</span><span class="sxs-lookup"><span data-stu-id="0e15c-265">**UNetAnchorRoot**</span></span>
    * <span data-ttu-id="0e15c-266">**UIContainer**</span><span class="sxs-lookup"><span data-stu-id="0e15c-266">**UIContainer**</span></span>
    * <span data-ttu-id="0e15c-267">**DebugPanelButton**</span><span class="sxs-lookup"><span data-stu-id="0e15c-267">**DebugPanelButton**</span></span>
* <span data-ttu-id="0e15c-268">像以前一样保存并生成</span><span class="sxs-lookup"><span data-stu-id="0e15c-268">Save and Build as before</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="0e15c-269">深入到代码中</span><span class="sxs-lookup"><span data-stu-id="0e15c-269">Digging into the code</span></span>

<span data-ttu-id="0e15c-270">在 "项目" 面板中，导航到 " **Assets\AppPrefabs\Support\SharingWithUnet\Scripts** "，然后双击 " **UnetAnchorManager.cs**"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-270">In the project panel, navigate to **Assets\AppPrefabs\Support\SharingWithUnet\Scripts** and double-click on **UnetAnchorManager.cs**.</span></span> <span data-ttu-id="0e15c-271">一个 HoloLens 与另一个 HoloLens 共享跟踪信息，使这两个设备可以共享相同空间的功能在神奇附近。</span><span class="sxs-lookup"><span data-stu-id="0e15c-271">The ability for one HoloLens to share tracking information with another HoloLens such that both devices can share the same space is near magical.</span></span> <span data-ttu-id="0e15c-272">当两个或多个用户可以使用相同的数字数据进行协作时，混合现实的强大功能将处于活动状态。</span><span class="sxs-lookup"><span data-stu-id="0e15c-272">The power of mixed reality comes alive when two or more people can collaborate using the same digital data.</span></span>

<span data-ttu-id="0e15c-273">在此脚本中需要指出的几点：</span><span class="sxs-lookup"><span data-stu-id="0e15c-273">A few things to point out in this script:</span></span>

<span data-ttu-id="0e15c-274">在 start 函数中，请注意对 **IsDisplayOpaque** 的检查。</span><span class="sxs-lookup"><span data-stu-id="0e15c-274">In the start function, notice the check for **IsDisplayOpaque**.</span></span> <span data-ttu-id="0e15c-275">在这种情况下，我们假设已建立定位点。</span><span class="sxs-lookup"><span data-stu-id="0e15c-275">In this case, we pretend that the Anchor is established.</span></span> <span data-ttu-id="0e15c-276">这是因为沉浸式耳机不公开导入或导出锚的方式。</span><span class="sxs-lookup"><span data-stu-id="0e15c-276">This is because the immersive headsets do not expose a way to import or export anchors.</span></span> <span data-ttu-id="0e15c-277">但是，如果我们在 HoloLens 上运行，则此脚本在设备之间实现共享锚。</span><span class="sxs-lookup"><span data-stu-id="0e15c-277">If we are running on a HoloLens, however, this script implements sharing anchors between the devices.</span></span> <span data-ttu-id="0e15c-278">启动会话的设备将创建用于导出的定位点。</span><span class="sxs-lookup"><span data-stu-id="0e15c-278">The device that starts the session will create an anchor for exporting.</span></span> <span data-ttu-id="0e15c-279">加入会话的设备将从启动会话的设备请求定位点。</span><span class="sxs-lookup"><span data-stu-id="0e15c-279">The device that joins a session will request the anchor from the device that started the session.</span></span>

<span data-ttu-id="0e15c-280">**输出**</span><span class="sxs-lookup"><span data-stu-id="0e15c-280">**Exporting:**</span></span>

<span data-ttu-id="0e15c-281">当用户创建会话时，NetworkDiscoveryWithAnchors 将调用 UNETAnchorManagers CreateAnchor 函数。</span><span class="sxs-lookup"><span data-stu-id="0e15c-281">When a user creates a session, NetworkDiscoveryWithAnchors will call UNETAnchorManagers CreateAnchor function.</span></span> <span data-ttu-id="0e15c-282">我们来看看 CreateAnchor flow。</span><span class="sxs-lookup"><span data-stu-id="0e15c-282">Let's follow CreateAnchor flow.</span></span>

<span data-ttu-id="0e15c-283">首先，我们会进行一些内务处理，清除我们为先前定位点收集的任何数据。</span><span class="sxs-lookup"><span data-stu-id="0e15c-283">We start by doing some housekeeping, clearing out any data we may have collected for previous anchors.</span></span> <span data-ttu-id="0e15c-284">然后检查是否有要加载的缓存锚。</span><span class="sxs-lookup"><span data-stu-id="0e15c-284">Then we check if there is a cached anchor to load.</span></span> <span data-ttu-id="0e15c-285">定位点数据的大小通常介于5到 20 MB 之间，因此重复使用缓存的定位点可以节省需要通过网络传输的数据量。</span><span class="sxs-lookup"><span data-stu-id="0e15c-285">The anchor data tends to be between 5 and 20 MB, so reusing cached anchors can save on the amount of data we need to transfer over the network.</span></span> <span data-ttu-id="0e15c-286">稍后我们将介绍此功能的工作原理。</span><span class="sxs-lookup"><span data-stu-id="0e15c-286">We'll see how this works a bit later.</span></span> <span data-ttu-id="0e15c-287">即使我们正在重用定位点，我们也需要在没有定位点的新客户端联接的情况下获取定位点数据。</span><span class="sxs-lookup"><span data-stu-id="0e15c-287">Even if we are reusing the anchor, we need to get the anchor data ready in case a new client joins that doesn't have the anchor.</span></span>

<span data-ttu-id="0e15c-288">说到定位点数据已准备就绪，WorldAnchorTransferBatch 类公开了准备用于发送到其他设备或应用程序的定位点数据的功能，并提供了导入定位数据的功能。</span><span class="sxs-lookup"><span data-stu-id="0e15c-288">Speaking of getting the anchor data ready, the WorldAnchorTransferBatch class exposes the functionality to prepare anchor data for sending to another device or application and the functionality to import the anchor data.</span></span> <span data-ttu-id="0e15c-289">由于我们的是导出路径，因此，我们会将定位点添加到 WorldAnchorTransferBatch 并调用 ExportAsync 函数。</span><span class="sxs-lookup"><span data-stu-id="0e15c-289">Since we're on the export path, we will add our anchor to the WorldAnchorTransferBatch and call the ExportAsync function.</span></span> <span data-ttu-id="0e15c-290">然后，ExportAsync 将调用 WriteBuffer 回调，因为它会生成导出的数据。</span><span class="sxs-lookup"><span data-stu-id="0e15c-290">ExportAsync will then call the WriteBuffer callback as it generates data for export.</span></span> <span data-ttu-id="0e15c-291">导出所有数据后，将调用 ExportComplete。</span><span class="sxs-lookup"><span data-stu-id="0e15c-291">When all of the data has been exported ExportComplete will be called.</span></span> <span data-ttu-id="0e15c-292">在 WriteBuffer 中，我们将数据块添加到要导出的列表。</span><span class="sxs-lookup"><span data-stu-id="0e15c-292">In WriteBuffer we add the chunk of data to a list we keep for exporting.</span></span> <span data-ttu-id="0e15c-293">在 ExportComplete 中，我们将列表转换为数组。</span><span class="sxs-lookup"><span data-stu-id="0e15c-293">In ExportComplete we convert the list to an array.</span></span> <span data-ttu-id="0e15c-294">还设置了 AnchorName 变量，这会触发其他设备请求定位点（如果没有）。</span><span class="sxs-lookup"><span data-stu-id="0e15c-294">The AnchorName variable is also set, which will trigger other devices to request the anchor if they don't have it.</span></span>

<span data-ttu-id="0e15c-295">在某些情况下，定位点将不会导出或创建很少的数据，我们将重试。</span><span class="sxs-lookup"><span data-stu-id="0e15c-295">In some cases the anchor won't export or will create so little data that we will try again.</span></span> <span data-ttu-id="0e15c-296">这里我们再次调用 CreateAnchor。</span><span class="sxs-lookup"><span data-stu-id="0e15c-296">Here we just call CreateAnchor again.</span></span>

<span data-ttu-id="0e15c-297">导出路径中的 final 函数为 AnchorFoundRemotely。</span><span class="sxs-lookup"><span data-stu-id="0e15c-297">A final function in the export path is AnchorFoundRemotely.</span></span> <span data-ttu-id="0e15c-298">当另一个设备找到定位点时，该设备将通知主机，主机会将其用作信号，指示锚点为 "良好锚定" 并可缓存。</span><span class="sxs-lookup"><span data-stu-id="0e15c-298">When another device finds the anchor, that device will tell the host, and the host will use that as a signal that the anchor is a "good anchor" and can be cached.</span></span>

<span data-ttu-id="0e15c-299">**导入**</span><span class="sxs-lookup"><span data-stu-id="0e15c-299">**Importing:**</span></span>

<span data-ttu-id="0e15c-300">当 HoloLens 加入会话时，它需要导入一个定位点。</span><span class="sxs-lookup"><span data-stu-id="0e15c-300">When a HoloLens joins a session, it needs to import an anchor.</span></span> <span data-ttu-id="0e15c-301">在 UNETAnchorManager 的 Update 函数中，将对 AnchorName 进行轮询。</span><span class="sxs-lookup"><span data-stu-id="0e15c-301">In UNETAnchorManager's Update function, the AnchorName is polled.</span></span> <span data-ttu-id="0e15c-302">定位点名称更改时，导入过程开始。</span><span class="sxs-lookup"><span data-stu-id="0e15c-302">When the anchor name changes, the import process begins.</span></span> <span data-ttu-id="0e15c-303">首先，我们尝试从本地定位点存储中加载具有指定名称的定位点。</span><span class="sxs-lookup"><span data-stu-id="0e15c-303">First, we try to load the anchor with the specified name from the local anchor store.</span></span> <span data-ttu-id="0e15c-304">如果已有该数据，则可以使用它，而无需再次下载数据。</span><span class="sxs-lookup"><span data-stu-id="0e15c-304">If we already have it, we can use it without downloading the data again.</span></span> <span data-ttu-id="0e15c-305">如果没有，请调用 WaitForAnchor，这将启动下载。</span><span class="sxs-lookup"><span data-stu-id="0e15c-305">If we don't have it, then we call WaitForAnchor which will initiate the download.</span></span>

<span data-ttu-id="0e15c-306">下载完成后，将调用 NetworkTransmitter_dataReadyEvent。</span><span class="sxs-lookup"><span data-stu-id="0e15c-306">When the download is completed, NetworkTransmitter_dataReadyEvent is called.</span></span> <span data-ttu-id="0e15c-307">这会向更新循环发出信号，以便对下载的数据调用 ImportAsync。</span><span class="sxs-lookup"><span data-stu-id="0e15c-307">This will signal the Update loop to call ImportAsync with the downloaded data.</span></span> <span data-ttu-id="0e15c-308">导入过程完成后，ImportAsync 将调用 ImportComplete。</span><span class="sxs-lookup"><span data-stu-id="0e15c-308">ImportAsync will call ImportComplete when the import process is complete.</span></span> <span data-ttu-id="0e15c-309">如果导入成功，定位点将保存在本地播放机存储区中。</span><span class="sxs-lookup"><span data-stu-id="0e15c-309">If the import is successful, the anchor will be saved in the local player store.</span></span> <span data-ttu-id="0e15c-310">PlayerController.cs 实际上会调用 AnchorFoundRemotely，让主机知道已经建立好锚。</span><span class="sxs-lookup"><span data-stu-id="0e15c-310">PlayerController.cs actually makes the call to AnchorFoundRemotely to let the host know that a good anchor has been established.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="0e15c-311">欣赏你的进度</span><span class="sxs-lookup"><span data-stu-id="0e15c-311">Enjoy your progress</span></span>

<span data-ttu-id="0e15c-312">这次使用 HoloLens 的用户将使用用户界面中的 " **启动会话** " 按钮来托管会话。</span><span class="sxs-lookup"><span data-stu-id="0e15c-312">This time a user with a HoloLens will host a session using the **start session** button in the UI.</span></span> <span data-ttu-id="0e15c-313">在 HoloLens 或沉浸式耳机上，其他用户将选择该会话，然后在 UI 中选择 " **加入会话** " 按钮。</span><span class="sxs-lookup"><span data-stu-id="0e15c-313">Other users, both on HoloLens or an immersive headset, will select the session and then select the **join session** button in the UI.</span></span> <span data-ttu-id="0e15c-314">如果有多个用户使用 HoloLens 设备，它们会在其打印头上包含红色的云。</span><span class="sxs-lookup"><span data-stu-id="0e15c-314">If you have multiple people with HoloLens devices, they will have red clouds over their heads.</span></span> <span data-ttu-id="0e15c-315">对于每个沉浸式耳机，还会有一个蓝色的云，但蓝色云不会位于耳机上方，因为耳机不会尝试查找与 HoloLens 设备相同的世界坐标空间。</span><span class="sxs-lookup"><span data-stu-id="0e15c-315">There will also be a blue cloud for each immersive headset, but the blue clouds will not be above the headsets, as the headsets are not trying to find the same world coordinate space as the HoloLens devices.</span></span>

<span data-ttu-id="0e15c-316">项目中的这一点是包含共享应用程序;这并不是很多，而且可以充当基线。</span><span class="sxs-lookup"><span data-stu-id="0e15c-316">This point in the project is a contained sharing application; it doesn't do very much, and could act as a baseline.</span></span> <span data-ttu-id="0e15c-317">在接下来的章节中，我们将开始为用户带来体验。</span><span class="sxs-lookup"><span data-stu-id="0e15c-317">In the next chapters, we will start building an experience for people to enjoy.</span></span> <span data-ttu-id="0e15c-318">若要获取有关共享体验设计的更多指导，请转到此处。</span><span class="sxs-lookup"><span data-stu-id="0e15c-318">To get further guidance on shared experience design, go here.</span></span>

## <a name="chapter-4---immersion-and-teleporting"></a><span data-ttu-id="0e15c-319">第4章-浸入式和 teleporting</span><span class="sxs-lookup"><span data-stu-id="0e15c-319">Chapter 4 - Immersion and teleporting</span></span>

>[!VIDEO https://www.youtube.com/embed/kUHZ5tCOfvY]

### <a name="objectives"></a><span data-ttu-id="0e15c-320">目标</span><span class="sxs-lookup"><span data-stu-id="0e15c-320">Objectives</span></span>

<span data-ttu-id="0e15c-321">为每种类型的混合现实设备满足经验。</span><span class="sxs-lookup"><span data-stu-id="0e15c-321">Cater the experience to each type of mixed reality device.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="0e15c-322">要生成的内容</span><span class="sxs-lookup"><span data-stu-id="0e15c-322">What we will build</span></span>

<span data-ttu-id="0e15c-323">我们将更新应用程序，以通过沉浸式视图将沉浸式头戴式耳机用户置于岛中。</span><span class="sxs-lookup"><span data-stu-id="0e15c-323">We will update the application to put immersive headset users on the island with an immersive view.</span></span> <span data-ttu-id="0e15c-324">HoloLens 用户仍将获得岛的鸟瞰视图。</span><span class="sxs-lookup"><span data-stu-id="0e15c-324">HoloLens users will still have the bird's eye view of the island.</span></span> <span data-ttu-id="0e15c-325">每种设备类型的用户可以看到其他用户出现在世界中。</span><span class="sxs-lookup"><span data-stu-id="0e15c-325">Users of each device type can see other users as they appear in the world.</span></span> <span data-ttu-id="0e15c-326">例如，沉浸式耳机用户可以查看岛上其他路径上的其他头像，并在岛上看到 HoloLens 用户为巨大的云。</span><span class="sxs-lookup"><span data-stu-id="0e15c-326">For instance, immersive headset users can see the other avatars on other paths on the island, and they see the HoloLens users as giant clouds above the island.</span></span> <span data-ttu-id="0e15c-327">如果 HoloLens 用户正在查看岛，则沉浸式耳机用户也会看到 HoloLens 用户的 "注视" 的光标。</span><span class="sxs-lookup"><span data-stu-id="0e15c-327">Immersive headset users will also see the cursor of the HoloLens user's gaze ray if the HoloLens user is looking at the island.</span></span> <span data-ttu-id="0e15c-328">HoloLens 用户将看到岛上的头像来表示每个沉浸式耳机用户。</span><span class="sxs-lookup"><span data-stu-id="0e15c-328">HoloLens users will see an avatar on the island to represent each immersive headset user.</span></span>

<span data-ttu-id="0e15c-329">**已更新沉浸式设备的输入：**</span><span class="sxs-lookup"><span data-stu-id="0e15c-329">**Updated Input for the Immersive device:**</span></span>

* <span data-ttu-id="0e15c-330">Xbox 控制器上的左缓冲器和右缓冲器按钮将旋转播放机</span><span class="sxs-lookup"><span data-stu-id="0e15c-330">The left bumper and right bumper buttons on the Xbox controller rotate the player</span></span>
* <span data-ttu-id="0e15c-331">按住 Xbox 控制器上的 Y 按钮将启用 [传送](../discover/navigating-the-windows-mixed-reality-home.md#getting-around-your-home) 光标。</span><span class="sxs-lookup"><span data-stu-id="0e15c-331">Holding the Y button on the Xbox controller will enable a [teleport](../discover/navigating-the-windows-mixed-reality-home.md#getting-around-your-home) cursor.</span></span> <span data-ttu-id="0e15c-332">如果在释放 Y 按钮时光标有旋转箭头指示器，则会 teleported 光标所在的位置。</span><span class="sxs-lookup"><span data-stu-id="0e15c-332">If the cursor has a spinning arrow indicator when you release the Y button, you will be teleported to the cursor's location.</span></span>

### <a name="steps"></a><span data-ttu-id="0e15c-333">步骤</span><span class="sxs-lookup"><span data-stu-id="0e15c-333">Steps</span></span>

* <span data-ttu-id="0e15c-334">将 MixedRealityTeleport 添加到 MixedRealityCameraParent</span><span class="sxs-lookup"><span data-stu-id="0e15c-334">Add MixedRealityTeleport to MixedRealityCameraParent</span></span>
    * <span data-ttu-id="0e15c-335">在 **层次结构** 中，选择 **Usland**。</span><span class="sxs-lookup"><span data-stu-id="0e15c-335">In **Hierarchy**, select **Usland**.</span></span>
    * <span data-ttu-id="0e15c-336">在 **检查器** 中，启用 **级别控制**。</span><span class="sxs-lookup"><span data-stu-id="0e15c-336">In **Inspector**, enable **Level Control**.</span></span>
    * <span data-ttu-id="0e15c-337">在 **层次结构** 中，选择 **MixedRealityCameraParent**。</span><span class="sxs-lookup"><span data-stu-id="0e15c-337">In **Hierarchy**, select **MixedRealityCameraParent**.</span></span>
    * <span data-ttu-id="0e15c-338">在 **检查器** 中，单击 " **添加组件**"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-338">In **Inspector**, click **Add Component**.</span></span>
    * <span data-ttu-id="0e15c-339">键入 **混合现实传送** 并将其选中。</span><span class="sxs-lookup"><span data-stu-id="0e15c-339">Type **Mixed Reality Teleport** and select it.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="0e15c-340">深入到代码中</span><span class="sxs-lookup"><span data-stu-id="0e15c-340">Digging into the code</span></span>

<span data-ttu-id="0e15c-341">沉浸式耳机用户将通过电缆受限到其电脑上，但岛比电缆长。</span><span class="sxs-lookup"><span data-stu-id="0e15c-341">Immersive headset users will be tethered to their PCs with a cable, but our island is larger than the cable is long.</span></span> <span data-ttu-id="0e15c-342">若要进行补偿，我们需要能够独立于用户的动作移动相机。</span><span class="sxs-lookup"><span data-stu-id="0e15c-342">To compensate, we need the ability to move the camera independently of the user's motion.</span></span> <span data-ttu-id="0e15c-343">有关设计混合现实应用 ([程序的详细](../design/comfort.md) 信息，请参阅 locomotion) 。</span><span class="sxs-lookup"><span data-stu-id="0e15c-343">Please see the [comfort page](../design/comfort.md) for more information about designing your mixed reality application (in particular self motion and locomotion).</span></span>

<span data-ttu-id="0e15c-344">若要描述此过程，请定义两个术语。</span><span class="sxs-lookup"><span data-stu-id="0e15c-344">In order to describe this process it will be useful to define two terms.</span></span> <span data-ttu-id="0e15c-345">首先， **dolly** 将是独立于用户移动相机的对象。</span><span class="sxs-lookup"><span data-stu-id="0e15c-345">First, **dolly** will be the object that moves the camera independently from the user.</span></span> <span data-ttu-id="0e15c-346">**Dolly** 的子游戏对象将是 **主摄像机**。</span><span class="sxs-lookup"><span data-stu-id="0e15c-346">A child game object of the **dolly** will be the **main camera**.</span></span> <span data-ttu-id="0e15c-347">将相机连接到用户的头。</span><span class="sxs-lookup"><span data-stu-id="0e15c-347">The main camera is attached to the user's head.</span></span>

<span data-ttu-id="0e15c-348">在 "项目" 面板中，导航到 " **Assets\AppPrefabs\Support\Scripts\GameLogic** "，然后双击 " **MixedRealityTeleport.cs**"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-348">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **MixedRealityTeleport.cs**.</span></span>

<span data-ttu-id="0e15c-349">MixedRealityTeleport 有两个作业。</span><span class="sxs-lookup"><span data-stu-id="0e15c-349">MixedRealityTeleport has two jobs.</span></span> <span data-ttu-id="0e15c-350">首先，它使用缓冲器处理旋转。</span><span class="sxs-lookup"><span data-stu-id="0e15c-350">First, it handles rotation using the bumpers.</span></span> <span data-ttu-id="0e15c-351">在更新函数中，我们轮询 LeftBumper 和 RightBumper 上的 "ButtonUp"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-351">In the update function we poll for 'ButtonUp' on LeftBumper and RightBumper.</span></span> <span data-ttu-id="0e15c-352">GetButtonUp 仅在第一帧上返回 true，按钮在关闭后就会正常运行。</span><span class="sxs-lookup"><span data-stu-id="0e15c-352">GetButtonUp only returns true on the first frame a button is up after having been down.</span></span> <span data-ttu-id="0e15c-353">如果引发了任一按钮，则我们知道用户需要旋转。</span><span class="sxs-lookup"><span data-stu-id="0e15c-353">If either button had been raised, then we know the user needs to rotate.</span></span>

<span data-ttu-id="0e15c-354">旋转时，我们使用名为 "淡化 control" 的简单脚本，进行淡出并淡出。</span><span class="sxs-lookup"><span data-stu-id="0e15c-354">When we rotate we do a fade out and fade in using a simple script called 'fade control'.</span></span> <span data-ttu-id="0e15c-355">这样做是为了防止用户看到可能导致 discomfort 的非自然移动。</span><span class="sxs-lookup"><span data-stu-id="0e15c-355">We do this to prevent the user from seeing an unnatural movement which could lead to discomfort.</span></span> <span data-ttu-id="0e15c-356">淡入和淡出效果非常简单。</span><span class="sxs-lookup"><span data-stu-id="0e15c-356">The fade in and out effect is fairly simple.</span></span> <span data-ttu-id="0e15c-357">在 **摄像机** 前面有一个黑色的故障诊断。</span><span class="sxs-lookup"><span data-stu-id="0e15c-357">We have a black quad hanging in front of the **main camera**.</span></span> <span data-ttu-id="0e15c-358">淡出时，将从0到1转换 alpha 值。</span><span class="sxs-lookup"><span data-stu-id="0e15c-358">When fading out we transition the alpha value from 0 to 1.</span></span> <span data-ttu-id="0e15c-359">这会逐渐导致四个黑色像素渲染和遮蔽。</span><span class="sxs-lookup"><span data-stu-id="0e15c-359">This gradually causes the black pixels of the quad to render and obscure anything behind them.</span></span> <span data-ttu-id="0e15c-360">当淡化后，转换后的 alpha 值将返回零。</span><span class="sxs-lookup"><span data-stu-id="0e15c-360">When fading back in we transition the alpha value back to zero.</span></span>

<span data-ttu-id="0e15c-361">计算旋转时，请注意，我们要旋转 **dolly** ，但计算出 **摄像机** 周围的旋转。</span><span class="sxs-lookup"><span data-stu-id="0e15c-361">When we calculate the rotation, note that we are rotating our **dolly** but calculating the rotation around the **main camera**.</span></span> <span data-ttu-id="0e15c-362">这一点很重要，因为在 **摄像机** 远离0，0，0时，dolly 的旋转就会从用户的角度来看。</span><span class="sxs-lookup"><span data-stu-id="0e15c-362">This is important as the farther the **main camera** is away from 0,0,0, the less accurate a rotation around the dolly would become from the point of view of the user.</span></span> <span data-ttu-id="0e15c-363">事实上，如果不围绕相机位置旋转，用户将在 **dolly** 上移动，而不是旋转。</span><span class="sxs-lookup"><span data-stu-id="0e15c-363">In fact, if you do not rotate around the camera position, the user will move on an arc around the **dolly** rather than rotating.</span></span>

<span data-ttu-id="0e15c-364">MixedRealityTeleport 的第二个作业是处理移动 **dolly**。</span><span class="sxs-lookup"><span data-stu-id="0e15c-364">The second job for MixedRealityTeleport is to handle moving the **dolly**.</span></span> <span data-ttu-id="0e15c-365">这是在 SetWorldPosition 中完成的。</span><span class="sxs-lookup"><span data-stu-id="0e15c-365">This is done in SetWorldPosition.</span></span> <span data-ttu-id="0e15c-366">SetWorldPosition 采用所需的世界位置，该位置是用户想要 percieve 具有的位置。</span><span class="sxs-lookup"><span data-stu-id="0e15c-366">SetWorldPosition takes the desired world position, the position where the user wants to percieve that they inhabit.</span></span> <span data-ttu-id="0e15c-367">我们需要将 **dolly** 置于该位置，而不是 **主摄像机** 的本地位置，因为每帧都会添加该偏移量。</span><span class="sxs-lookup"><span data-stu-id="0e15c-367">We need to put our **dolly** at that position minus the local position of the **main camera**, as that offset will be added each frame.</span></span>

<span data-ttu-id="0e15c-368">第二个脚本调用 SetWorldPosition。</span><span class="sxs-lookup"><span data-stu-id="0e15c-368">A second script calls SetWorldPosition.</span></span> <span data-ttu-id="0e15c-369">让我们看看该脚本。</span><span class="sxs-lookup"><span data-stu-id="0e15c-369">Let's look at that script.</span></span> <span data-ttu-id="0e15c-370">在 "项目" 面板中，导航到 " **Assets\AppPrefabs\Support\Scripts\GameLogic** "，然后双击 " **TeleportScript.cs**"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-370">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **TeleportScript.cs**.</span></span>

<span data-ttu-id="0e15c-371">此脚本比 MixedRealityTeleport 更复杂一些。</span><span class="sxs-lookup"><span data-stu-id="0e15c-371">This script is a little more involved than MixedRealityTeleport.</span></span> <span data-ttu-id="0e15c-372">脚本正在检查 Xbox 控制器上的 Y 按钮是否已关闭。</span><span class="sxs-lookup"><span data-stu-id="0e15c-372">The script is checking for the Y Button on the Xbox controller to be held down.</span></span> <span data-ttu-id="0e15c-373">当按钮被按下时，将呈现一个传送光标，并且该脚本将从用户的注视位置转换一条射线。</span><span class="sxs-lookup"><span data-stu-id="0e15c-373">While the button is held down a teleport cursor is rendered and the script casts a ray from the user's gaze position.</span></span> <span data-ttu-id="0e15c-374">如果该射线与更多或更少地指向的图面冲突，则会将该图面视为传送到的一个好图面，并将启用传送光标上的动画。</span><span class="sxs-lookup"><span data-stu-id="0e15c-374">If that ray collides with a surface that is more or less pointing up, the surface will be considered a good surface to teleport to, and the animation on the teleport cursor will be enabled.</span></span> <span data-ttu-id="0e15c-375">如果该射线不会与某个面上更多或更少的向上箭头发生冲突，则将禁用游标上的动画。</span><span class="sxs-lookup"><span data-stu-id="0e15c-375">If the ray does not collide with a surface more or less pointing up, then the animation on the cursor will be disabled.</span></span> <span data-ttu-id="0e15c-376">当 "Y" 按钮被释放并且射线的计算点为有效位置时，该脚本将使用与该射线相交的位置来调用 SetWorldPosition。</span><span class="sxs-lookup"><span data-stu-id="0e15c-376">When the Y button is released and the calculated point of the ray is a valid position, the script calls SetWorldPosition with the position the ray intersected.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="0e15c-377">欣赏你的进度</span><span class="sxs-lookup"><span data-stu-id="0e15c-377">Enjoy your progress</span></span>

<span data-ttu-id="0e15c-378">这次您需要查找朋友。</span><span class="sxs-lookup"><span data-stu-id="0e15c-378">This time you'll need to find a friend.</span></span>

<span data-ttu-id="0e15c-379">同样，具有 HoloLens 的用户将托管一个会话。</span><span class="sxs-lookup"><span data-stu-id="0e15c-379">Once again, a user with the HoloLens will host a session.</span></span> <span data-ttu-id="0e15c-380">其他用户将加入会话。</span><span class="sxs-lookup"><span data-stu-id="0e15c-380">Other users will join the session.</span></span> <span data-ttu-id="0e15c-381">应用程序将把前三名用户加入到岛上三个路径之一上的沉浸式耳机上。</span><span class="sxs-lookup"><span data-stu-id="0e15c-381">The application will place the first three users to join from an immersive headset on one of the three paths on the island.</span></span> <span data-ttu-id="0e15c-382">请随时浏览本部分中的岛。</span><span class="sxs-lookup"><span data-stu-id="0e15c-382">Feel free to explore the island in this section.</span></span>

<span data-ttu-id="0e15c-383">要注意的详细信息：</span><span class="sxs-lookup"><span data-stu-id="0e15c-383">Details to notice:</span></span>

1. <span data-ttu-id="0e15c-384">你可以在云中看到人脸，这有助于沉浸用户查看 HoloLens 用户正在寻找的方向。</span><span class="sxs-lookup"><span data-stu-id="0e15c-384">You can see faces in the clouds, which helps an immersed user see which direction a HoloLens user is looking.</span></span>
2. <span data-ttu-id="0e15c-385">岛上的头像具有旋转 necks。</span><span class="sxs-lookup"><span data-stu-id="0e15c-385">The avatars on the island have necks that rotate.</span></span> <span data-ttu-id="0e15c-386">它们不会遵循用户正在执行的操作， (我们没有) 的信息，而是为了获得良好的体验。</span><span class="sxs-lookup"><span data-stu-id="0e15c-386">They won't follow what the user is doing is real reality (we don't have that information) but it makes for a nice experience.</span></span>
3. <span data-ttu-id="0e15c-387">如果 HoloLens 用户正在查看岛，沉浸用户会看到其光标。</span><span class="sxs-lookup"><span data-stu-id="0e15c-387">If the HoloLens user is looking at the Island, the immersed users can see their cursor.</span></span>
4. <span data-ttu-id="0e15c-388">表示 HoloLens 用户投影的云。</span><span class="sxs-lookup"><span data-stu-id="0e15c-388">The clouds that represent the HoloLens users cast shadows.</span></span>

## <a name="chapter-5---finale"></a><span data-ttu-id="0e15c-389">第5章-Finale</span><span class="sxs-lookup"><span data-stu-id="0e15c-389">Chapter 5 - Finale</span></span>

>[!VIDEO https://www.youtube.com/embed/n_HDWJbfpNg]

### <a name="objectives"></a><span data-ttu-id="0e15c-390">目标</span><span class="sxs-lookup"><span data-stu-id="0e15c-390">Objectives</span></span>

<span data-ttu-id="0e15c-391">在这两种设备类型之间创建协作式交互式体验。</span><span class="sxs-lookup"><span data-stu-id="0e15c-391">Create a collaborative interactive experience between the two device types.</span></span>

### <a name="what-we-will-build"></a><span data-ttu-id="0e15c-392">要生成的内容</span><span class="sxs-lookup"><span data-stu-id="0e15c-392">What we will build</span></span>

<span data-ttu-id="0e15c-393">在第4章，当具有沉浸式耳机的用户在岛上出现谜题附近时，HoloLens 用户将收到一条工具提示，其中包含对测验题的线索。</span><span class="sxs-lookup"><span data-stu-id="0e15c-393">Building on chapter 4, when a user with an immersive headset gets near a puzzle on the island, the HoloLens users will get a tool tip with a clue to the puzzle.</span></span> <span data-ttu-id="0e15c-394">所有沉浸式耳机用户都在火箭房间内进入了测验题后，就会启动火箭。</span><span class="sxs-lookup"><span data-stu-id="0e15c-394">Once all of the immersive headset users get past their puzzles and onto the "ready pad" in the rocket room, the rocket will launch.</span></span>

### <a name="steps"></a><span data-ttu-id="0e15c-395">步骤</span><span class="sxs-lookup"><span data-stu-id="0e15c-395">Steps</span></span>

* <span data-ttu-id="0e15c-396">在 **层次结构** 中，选择 **Usland**。</span><span class="sxs-lookup"><span data-stu-id="0e15c-396">In **Hierarchy**, select **Usland**.</span></span>
* <span data-ttu-id="0e15c-397">在 **检查器** 的 " **级别控制**" 中，选中 " **启用协作**"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-397">In **Inspector**, in **Level Control**, check **Enable Collaboration**.</span></span>

### <a name="digging-into-the-code"></a><span data-ttu-id="0e15c-398">深入到代码中</span><span class="sxs-lookup"><span data-stu-id="0e15c-398">Digging into the code</span></span>

<span data-ttu-id="0e15c-399">现在让我们看看 LevelControl.cs。</span><span class="sxs-lookup"><span data-stu-id="0e15c-399">Now let us look at LevelControl.cs.</span></span> <span data-ttu-id="0e15c-400">此脚本是游戏逻辑的核心，并且保持游戏状态。</span><span class="sxs-lookup"><span data-stu-id="0e15c-400">This script is the core of the game logic and maintains the game state.</span></span> <span data-ttu-id="0e15c-401">由于这是一个使用 UNET 的多玩家游戏，我们需要了解数据的流动方式，至少足以修改本教程。</span><span class="sxs-lookup"><span data-stu-id="0e15c-401">Since this is a multiplayer game using UNET we need to understand how data flows, at least well enough to modify this tutorial.</span></span> <span data-ttu-id="0e15c-402">有关 UNET 的更完整概述，请参阅 Unity 的文档。</span><span class="sxs-lookup"><span data-stu-id="0e15c-402">For a more complete overview of UNET, please refer to Unity's documentation.</span></span>

<span data-ttu-id="0e15c-403">在 "项目" 面板中，导航到 " **Assets\AppPrefabs\Support\Scripts\GameLogic** "，然后双击 " **LevelControl.cs**"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-403">In the project panel, navigate to **Assets\AppPrefabs\Support\Scripts\GameLogic** and double-click on **LevelControl.cs**.</span></span>

<span data-ttu-id="0e15c-404">让我们了解沉浸式耳机如何指示它们已准备好进行火箭启动。</span><span class="sxs-lookup"><span data-stu-id="0e15c-404">Let us understand how an immersive headset indicates that they are ready for the rocket launch.</span></span> <span data-ttu-id="0e15c-405">通过在与岛上的三个路径相对应的布尔列表中设置三个布尔之一，可以传达火箭的启动准备情况。</span><span class="sxs-lookup"><span data-stu-id="0e15c-405">Rocket Launch readiness is communicated by setting one of three bools in a list of bools that correspond to the three paths on the island.</span></span> <span data-ttu-id="0e15c-406">当分配到路径的用户在火箭房间内的棕色垫的顶部时，将设置路径的 bool。</span><span class="sxs-lookup"><span data-stu-id="0e15c-406">A path's bool will be set when the user assigned to the path is on top of the brown pad inside the rocket room.</span></span> <span data-ttu-id="0e15c-407">好了，现在来了解详细信息。</span><span class="sxs-lookup"><span data-stu-id="0e15c-407">Okay, now to the details.</span></span>

<span data-ttu-id="0e15c-408">我们将从更新 ( # A1 函数开始。</span><span class="sxs-lookup"><span data-stu-id="0e15c-408">We will start in the Update() function.</span></span> <span data-ttu-id="0e15c-409">你会注意到有一个 "使用" 函数。</span><span class="sxs-lookup"><span data-stu-id="0e15c-409">You will note that there is a 'cheat' function.</span></span> <span data-ttu-id="0e15c-410">我们在开发过程中使用这种测试火箭启动和重置顺序。</span><span class="sxs-lookup"><span data-stu-id="0e15c-410">We used this in development to test the rocket launch and reset sequence.</span></span> <span data-ttu-id="0e15c-411">它在多用户体验中不起作用。</span><span class="sxs-lookup"><span data-stu-id="0e15c-411">It won't work in the multi user experience.</span></span> <span data-ttu-id="0e15c-412">但愿您内在化以下信息可以使其正常工作。</span><span class="sxs-lookup"><span data-stu-id="0e15c-412">Hopefully by the time you internalize the following infromation you can make it work.</span></span> <span data-ttu-id="0e15c-413">检查是否应该是，我们会检查是否已沉浸本地播放器。</span><span class="sxs-lookup"><span data-stu-id="0e15c-413">After we check to see if we should cheat, we check to see if the local player is immersed.</span></span> <span data-ttu-id="0e15c-414">我们想要重点介绍我们的目标。</span><span class="sxs-lookup"><span data-stu-id="0e15c-414">We want to focus on how we find that we're at the goal.</span></span> <span data-ttu-id="0e15c-415">在 if (沉浸) 检查的情况下，调用 CheckGoal 隐藏在 **EnableCollaboration** bool 后面。</span><span class="sxs-lookup"><span data-stu-id="0e15c-415">Inside of the if (Immersed) check, there is a call to CheckGoal hiding behind the **EnableCollaboration** bool.</span></span> <span data-ttu-id="0e15c-416">这对应于完成本章中的步骤时选中的复选框。</span><span class="sxs-lookup"><span data-stu-id="0e15c-416">This corresponds to the checkbox you checked while completing the steps for this chapter.</span></span> <span data-ttu-id="0e15c-417">在 EnableCollaboration 内部，我们看到对 CheckGoal ( # A1 的调用。</span><span class="sxs-lookup"><span data-stu-id="0e15c-417">Inside of EnableCollaboration we see a call to CheckGoal().</span></span>

<span data-ttu-id="0e15c-418">CheckGoal 进行一些数学计算，看看是否有更多或更少的时间。</span><span class="sxs-lookup"><span data-stu-id="0e15c-418">CheckGoal does some math to see if we are more or less standing on the pad.</span></span> <span data-ttu-id="0e15c-419">当我们进行调试时，我们将进行调试。记录 "到达目标"，然后调用 "SendAtGoalMessage ( # A1"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-419">When we are, we Debug.Log "Arrived at goal" and then we call 'SendAtGoalMessage()'.</span></span> <span data-ttu-id="0e15c-420">在 SendAtGoalMessage 中，我们调用 playerController. SendAtGoal。</span><span class="sxs-lookup"><span data-stu-id="0e15c-420">In SendAtGoalMessage we call playerController.SendAtGoal.</span></span> <span data-ttu-id="0e15c-421">为节省时间，请参阅以下代码：</span><span class="sxs-lookup"><span data-stu-id="0e15c-421">To save you some time, here's the code:</span></span>

```cs
private void CmdSendAtGoal(int GoalIndex)
{
    levelState.SetGoalIndex(GoalIndex);
}
```

```cs
public void SendAtGoal(int GoalIndex)
{
    if (isLocalPlayer)
    {
        Debug.Log("sending at goal " + GoalIndex);
        CmdSendAtGoal(GoalIndex);
    }
}
```

<span data-ttu-id="0e15c-422">请注意，SendAtGoalMessage 调用 CmdSendAtGoal，后者会调用中的 levelState。</span><span class="sxs-lookup"><span data-stu-id="0e15c-422">Note that SendAtGoalMessage calls CmdSendAtGoal, which calls levelState.SetGoalIndex, which is back in LevelControl.cs.</span></span> <span data-ttu-id="0e15c-423">乍一看，这似乎很奇怪。</span><span class="sxs-lookup"><span data-stu-id="0e15c-423">At first glance this seems strange.</span></span> <span data-ttu-id="0e15c-424">为什么不只调用 SetGoalIndex 而不是通过播放机控制器进行这种奇怪的路由？</span><span class="sxs-lookup"><span data-stu-id="0e15c-424">Why not just call SetGoalIndex rather than this strange routing through the player controller?</span></span> <span data-ttu-id="0e15c-425">原因是我们符合数据模型，UNET 使用该数据来使数据保持同步。若要防止作弊和抖动，UNET 要求每个对象都有一个有权更改同步变量的用户。</span><span class="sxs-lookup"><span data-stu-id="0e15c-425">The reason is that we are conforming to the data model UNET uses to keep data in sync. To prevent cheating and thrashing, UNET requires that each object has a user who has authority to change the synchronized variables.</span></span> <span data-ttu-id="0e15c-426">此外，只有启动会话) 用户 (的主机可以直接更改数据。</span><span class="sxs-lookup"><span data-stu-id="0e15c-426">Further, only the host (the user that started the session) can change data directly.</span></span> <span data-ttu-id="0e15c-427">如果用户不是宿主但具有权限，则需要将 "command" 发送到将更改变量的主机。</span><span class="sxs-lookup"><span data-stu-id="0e15c-427">Users who are not the host, but have authority, need to send a 'command' to the host which will change the variable.</span></span> <span data-ttu-id="0e15c-428">默认情况下，主机拥有所有对象的权限，但生成的对象除外表示用户。</span><span class="sxs-lookup"><span data-stu-id="0e15c-428">By default the host has authority over all objects, except for the object spawned to represent the user.</span></span> <span data-ttu-id="0e15c-429">在本例中，此对象具有 playercontroller 脚本。</span><span class="sxs-lookup"><span data-stu-id="0e15c-429">In our case this object has the playercontroller script.</span></span> <span data-ttu-id="0e15c-430">有一种方法可以为对象请求授权，然后进行更改，但我们选择利用这一事实：播放机控制器具有己方授权，并通过播放机控制器路由命令。</span><span class="sxs-lookup"><span data-stu-id="0e15c-430">There is a way to request authority for an object and then make changes, but we choose to leverage the fact that the player controller has self authority and route commands through the player controller.</span></span>

<span data-ttu-id="0e15c-431">另一种方法是，当我们以我们的目标找到自己时，玩家需要告诉主机，主机会告诉所有其他人。</span><span class="sxs-lookup"><span data-stu-id="0e15c-431">Said another way, when we've found ourselves at our goal, the player needs to tell the host, and the host will tell everyone else.</span></span>

<span data-ttu-id="0e15c-432">返回 LevelControl.cs 查看 SetGoalIndex。</span><span class="sxs-lookup"><span data-stu-id="0e15c-432">Back in LevelControl.cs look at SetGoalIndex.</span></span> <span data-ttu-id="0e15c-433">这里，我们要在 synclist (AtGoal) 中设置值的值。</span><span class="sxs-lookup"><span data-stu-id="0e15c-433">Here we are setting the value of a value in a synclist (AtGoal).</span></span> <span data-ttu-id="0e15c-434">请记住，在执行此操作时，我们处于主机的上下文中。</span><span class="sxs-lookup"><span data-stu-id="0e15c-434">Remember that we are in the context of the host while we do this.</span></span> <span data-ttu-id="0e15c-435">与命令相似，RPC 是指主机可以发出的，这会导致所有客户端运行一些代码。</span><span class="sxs-lookup"><span data-stu-id="0e15c-435">Similar to a command, an RPC is something the host can issue that will cause all clients to run some code.</span></span> <span data-ttu-id="0e15c-436">这里我们称之为 "RpcCheckAllGoals"。</span><span class="sxs-lookup"><span data-stu-id="0e15c-436">Here we call 'RpcCheckAllGoals'.</span></span> <span data-ttu-id="0e15c-437">每个客户端将分别检查是否设置了所有三个 AtGoals，如果已设置，则启动火箭。</span><span class="sxs-lookup"><span data-stu-id="0e15c-437">Each client will individually check to see if all three AtGoals are set, and if so, launch the rocket.</span></span>

### <a name="enjoy-your-progress"></a><span data-ttu-id="0e15c-438">欣赏你的进度</span><span class="sxs-lookup"><span data-stu-id="0e15c-438">Enjoy your progress</span></span>

<span data-ttu-id="0e15c-439">在上一章中生成，我们将像以前一样启动会话。</span><span class="sxs-lookup"><span data-stu-id="0e15c-439">Building on the previous chapter, we will start the session as before.</span></span> <span data-ttu-id="0e15c-440">这一次，沉浸式头戴显示设备上的用户到达其路径上的 "门" 时，会出现一个工具提示，只有 HoloLens 用户可以看到。</span><span class="sxs-lookup"><span data-stu-id="0e15c-440">This time as the users in the immersive headset get to the "door" on their path, a tooltip will appear that only the HoloLens users can see.</span></span> <span data-ttu-id="0e15c-441">HoloLens 用户负责将此线索传达给沉浸式耳机中的用户。</span><span class="sxs-lookup"><span data-stu-id="0e15c-441">The HoloLens users are responsible for communicating this clue to the users in the immersive headset.</span></span> <span data-ttu-id="0e15c-442">一旦每个虚拟形象在火山内的相应的棕色垫上火箭，就会启动空间。</span><span class="sxs-lookup"><span data-stu-id="0e15c-442">The rocket will launch to space once each avatar has stepped on its corresponding brown pad inside the volcano.</span></span> <span data-ttu-id="0e15c-443">场景将在60秒后重置，因此你可以重新执行此操作。</span><span class="sxs-lookup"><span data-stu-id="0e15c-443">The scene will reset after 60 seconds so you can do it again.</span></span>

## <a name="see-also"></a><span data-ttu-id="0e15c-444">另请参阅</span><span class="sxs-lookup"><span data-stu-id="0e15c-444">See also</span></span>

* [<span data-ttu-id="0e15c-445">MR 输入 213：运动控制器</span><span class="sxs-lookup"><span data-stu-id="0e15c-445">MR Input 213: Motion controllers</span></span>](mixed-reality-213.md)